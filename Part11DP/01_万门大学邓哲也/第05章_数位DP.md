# 第05章 数位DP
## 5.1 数位DP的通用解法
### 问题的一般形式是这样的：

定义一个条件A，比如：被7整除、数位中含有3等等，询问区间[L, R]中有几个数满足条件A

L和R的范围一般非常大，比如$10^{18}$，通过数位DP，我们会发现这些问题的规模实际上是$log_{10}R$

数位DP就是考虑数字的每一位，问题的规模变为$log_{10}N$，每一位作为不同的阶段，设计状态。我们从高位往低位依次枚举(高位往地位枚举，当高位确定时，低位能确定下来；但是低位确定下来，高位不一定能确定下来)。

每一位的数选择的范围是不同的，依据前面选的数决定

比如N是1230，假设前两位枚举的数是1和2，也就是计算了12开头的贡献，此时枚举第三位，可选的范围只有0到3(`要是第3位大于3，那么12xx肯定要大约1230了`)；如果前两位枚举的数是1和0，此时枚举第三位，可选的范围就是0到9(`因为10xx肯定是小于1230的，所以后面两位都随便取就好啦`)

因此我们用一个变量eq或者less表示在**枚举当前位之前**，**每一位是不是都和N选地一样**，具体情况如下：
+ 1.前面一位小于N对应位上的数，那么当前位及后面的位就都可以随便选了(0~9都可以)，即后面的位都不用判了
+ 2.前面一位等于N对应位上的数，那么当前位的数必须小于等于N对应位上的数，按照123的逻辑继续判下一位即可
+ 3.前面一位大于N对应位上的数，不用判了，肯定不符合题目要求了(实际我们再判前面一位的时候根本不会去枚举到这种大于N对应位的情况)

### 具体代码逻辑如下：

当前位设为第dep位，N的第dep位为A[dep]，假设天上k，如果填上k，
+ 如果采用eq变量，$eq = (eq && (A[dep] == k)) $，表示前面的位以及当前的第dep位是否都和N的对应位相等。
  > 可选的最大值是：$eq ? A[dep] : 9$，解释如下：
  + 如果eq为真，表示当前位及往前的位都和N相等，当前位只能填N对应的位即A[dep]
  + 如果eq为假，表示前面的各位中有一些位小于N的对应位了，当前位随便填0~9都可以，最大值显然是9
+ 如果采用less变量，$less = (less || (A[dep] > k))$，表示前面的位以及当前的第dep位是否有小于N的对应位的
  > 可选的最大值计算表达式是：$less ? 9 : A[dep]$，解释如下：
  + 如果less为真，表示前面的各位中有一些位小于N的对应位了，当前位随便填0~9都可以，最大值显然是9
  + 如果less为假，表示当前位及往前的位都和N相等，当前位只能填N对应的位即A[dep]

### 为了直观地理解数位DP，我们举个例子[BZOJ 1799 同类分布](https://www.luogu.com.cn/problem/P4127)
> 询问[L, R]中各位数字之和能整除原数的个数，$1 ≤ L ≤ R ≤ 10^{18}$，比如120的各位数字之和 = 1+2+0=3,120/3=40，能整除，因此算一个满足题意的数字

这里我们介绍记忆化搜索的形式，高位的答案由低位转移而来

假设[0, x]内满足条件的数字个数为f[x]，那么根据前缀和的原理可以知道$$f[L到R] = f[R] - f[L - 1]$$

可以发现18位长的数字，其各位数之和最大只能为 $ sum_{max} = 9 * 18 = 162$，我们可以枚举这个和sum，然后去统计可以被sum整除，且数位和是sum的数。

我们把状态定义为$f[dep][cur][mod]$，表示当前枚举到第$dep$位，目前这个数的数位和是$cur$，对$sum$取模得到的余数是$mod$.

$cur == sum$且$mod == 0$的个数要统计进答案

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
ll l, r, dp[20][200][200];
int len, a[20], mod;

/**
 * 深度优先搜索查找满足限制条件下的数字个数
 * @param pos 枚举到第pos位了
 * @param sum 当前数字各位上的数的和
 * @param st 原始数字
 * @param limit 前面的各位数字是否都相等
 * @return
 */
ll dfs(int pos, int sum, ll st, int limit) {
    if (pos > len && sum == 0) return 0; // 遍历到的位置已经大于题目给的数字的长度了，肯定找不到符合题意的数字了，所以返回；sum等于0表示dfs刚进来就检测到不合适了
    if (pos > len) return st == 0 && sum == mod ? 1 : 0; // 当前数已经模mod成0了，且数字之和正好等于模mod，即当前数能被自己的各位数字之和整除，满足题意，返回即可
    if (!limit && dp[pos][sum][st] != -1) return dp[pos][sum][st]; // limit为false，表明前一位不相等，因此当前位可以取0~9，则dp[pos][sum][st]可以复用；如果为true，那么当前位的取值和N有关，不能直接套之前的值了
    ll ret = 0;
    int res = limit ? a[len - pos + 1] : 9; // 从高位往低位取，前面的都相等就取当前值，否则上限取9
    for (int i = 0; i <= res; i++) // 遍历当前位的所有可能性，10ll * st + i表示之前的数在把当前遍历到的位拼接上称为下一个数
        ret += dfs(pos + 1, sum + i, (10ll * st + i) % mod, i == res && limit); // 固定当前位，DFS看下一位
    if(!limit) dp[pos][sum][st] = ret; // 上一位不相等，当前位的dp值才需要更新
    return ret;
}

// 计算1~x内能被自己的数位和整除的数
ll part(ll x) {
    len = 0;
    while (x) a[++len] = x % 10, x /= 10;
    ll ret = 0;
    for (mod = 1; mod <= 9 * len; mod++) { // 枚举模数（就是各位数之和），每一轮DFS都固定一个mod
        memset(dp, -1, sizeof dp);
        ret += dfs(1, 0, 0, 1); // a数组是从1开始地，所以我们开始遍历的位置也从1开始；初始时各位数字和为0；原始数字从0开始；默认前面的各位都相等
    }
    return ret;
}

int main() {
    scanf("%lld%lld", &l, &r);
    printf("%lld\n", part(r) - part(l - 1));
    return 0;
}
```

## 5.2~5.5 知识精练
### [HDU 3709 Balanced Number](http://acm.hdu.edu.cn/showproblem.php?pid=3709)
> 题解：https://www.cnblogs.com/shenben/p/6708758.html

定义一个数是平衡的，当且仅当把它看成一个杠杆，存在一个支点使它平衡。

例如4139。当3作为支点时，左边的力矩是$4 * 2 + 1 * 1 = 9$，右边的力矩是$9 * 1 = 9$，所以这个杠杆是平衡的，因此4139是平衡数，请问区间$[L, R]$内有多少个平衡数，其中$0 ≤ L ≤ R ≤ 10^{18}$

> 首先仍然把问题转化为求解小于等于N的数有几个符合要求，由前缀和的基础知识可知：假设[0, x]内满足条件的数字个数为f[x]，那么根据前缀和的原理可以知道$$f[L到R] = f[R] - f[L - 1]$$这样。

下面考虑如何设计状态：一个数只会有一个支点，因此我们可以枚举支点的位置去统计答案，这样也不会重复

支点固定了之后，算力矩就简单了，左右的力矩和需要算出，并且到最后一步需要判断是否相等。简单起见我们只需要存(左力矩和 - 右力矩和)，最后一步判断是否为0即可

我们可以把状态设置为$f[less][pos][center][sum]$，表示当前枚举到了第pos位，力矩支点枚举到了第pos位，当前的(左力矩和 - 右力矩和)为sum。

假设当前枚举到的支点为center，那么在第pos位上填上i，就会对sum产生$i*(pos - center)$的贡献。具体代码实现如下：

### [HDU 4507 恨7不成妻](http://acm.hdu.edu.cn/showproblem.php?pid=4507)
> 题解：https://blog.csdn.net/qq_37025443/article/details/78472991
### [CF55D Beautiful numbers](https://www.luogu.com.cn/problem/CF55D)
> 题解：https://www.luogu.com.cn/problem/solution/CF55D

