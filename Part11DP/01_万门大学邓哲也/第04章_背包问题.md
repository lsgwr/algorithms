# 第04章_背包问题
## 4.1 01背包和完全背包问题
### 01背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是c[i]、价值是w[i]，**每种物品只可以使用一次**，求将哪些物品放入背包可以使得价值总和最大

这是最基础的背包问题，"01"就是指每种物品要么选要么不选，我们定义状态$dp[i][j]$表示从前i件物品中选出容量为j的背包能获得的最大价值

> 状态定义，根据第i个物品选还是不选，分成两种情况
+ 选第i个物品，$dp[i][j] = dp[i - 1][j - c[i]] + w[i]$，即从剩余的i-1个物品中选取容量总和为j-c[i]的物品，其价值加上第i个物品的价值w[i]即为最大价值
+ 不选第i个物品，$dp[i][j] = dp[i - 1][j]$，即从剩余的i-1个物品中选取容量总和为j的物品，其价值即为最大价值

取两者的较大值即为最终的最大价值$dp[i][j] = max(dp[i - 1][j - c[i]] + w[i], dp[i - 1][j])$

> 上面求dp[i][j]的时空复杂度都是$O(NV)$，这是优点高的，如何优化呢？

注意到每次我们都是从$dp[i - 1]$递推到$dp[i]$，可以只用O(V)的空间存下一步的f吗？即下一轮的i覆盖上一轮的i，i这一维度只保留长度为1即可，进一步可以直接把第一层去掉，只用j这个第二维度，伪代码如下：
```java
for(int i = 1; i <= N; i++) {
    for(int j = V; j >= c[i]; j--) { // 这里的V为什么是从大到小呢？下面会讲解地
        dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
    }
}
```
这里的V为什么是从大到小呢？因为这样每次计算dp[j]的时候，dp[V...j+1]已经是新的一轮的值了，而$dp[j]$和$dp[j - c[i]]$(分别压缩前的`dp[i - 1][j]`和`dp[i - 1][j - c[i]]`)肯定还没被更新，即为上一轮的值，用上一轮的值更新本轮的值，这样才符合动态规划的套路.

如果V从小到大，那么$dp[j]$和$dp[j - c[i]]$就会在计算dp[j]之前被更新了，这样会导致不能用上一轮的值更新本轮的值，显然不符合动态规划的套路。

> 初始化时的一些要求：

初始化时$dp[0] = 0; dp[1...V] = +∞$
如果要求背包装满，答案就是$dp[V]$，如果可以不装满，答案就是$max(dp[1...V])$

### 完全背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是c[i]、价值是w[i]，**每种物品都可以无限次使用**，求将哪些物品放入背包可以使得价值总和最大

> 状态定义:

假设第i个物品被选择了k次，易知k的范围为 $0 ≤ k * c[i] ≤ j$，相对于背包的选或不选，这里需要for循环不断更新选择的次数k，因此，动态规划的状态表达式就变成了

$dp[i][j] = max(dp[i - 1][j - k * c[i]] + k * w[i]  |  0 ≤ k * c[i] ≤ j)$ 含义是第i个物品选k次，从剩余的i-1个物品中选取物品来满足容量$j - k * c[i]$的限制

> 时间复杂度为$O(NV * ∑(V/c[i]))$，已经是相当大了，类比下01背包的二维降为一维的解法，看看能不能优化

实际只需要把01背包问题的V的倒向循环改成正向循环即可，代码如下：
```java
for(int i = 1; i <=n; i++) {
    for(int j = c[i]; j <= V; j--) { // 这里的V为什么是从小到大呢？下面会讲解地
        dp[j] = Math.max(dp[j], dp[j - c[i]] + w[i]);
    }
}
```
V为什么是从小到大呢？因为每次算dp[j]的时候，dp[j - c[i]]表示地是用前i个物品(可能已经拿过第i个物品了)凑出体积为`j - c[i]`的最大价值，此时不仅空间复杂度变成了$O(V)$，时间复杂度也变成了$O(NV)$

### 01背包和完全背包问题对比
图自己从视频里截取

## 4.2 多重背包问题二进制拆分优化
### 多重背包问题
> 有N件物品和一个容量为V的背包，第i件物品的体积是c[i]、价值是w[i]，**每种物品只可以使用a[i]次**，求将哪些物品放入背包可以使得价值总和最大

**多重背包**问题和**01背包**问题、**完全背包**问题的不同之处在于指定了第i个物品的使用次数，即每个物品的使用次数都可能是不同的

> 状态分析

$dp[i][j] = max(dp[i - 1][j - k * c[i]] + k * w[i]  |  0 ≤ k * c[i] ≤ a[i])$

> 时间复杂度为$O(NV * ∑(a[i]))$了，需要优化

### 多重背包问题二进制拆分优化
拿上面的题的具体化举例，比如一个物品最多有15个可用，15的二进制是1111，那么可以把这个物品拆成4份，分别代表8个物品、4个物品、2个物品、1个物品，此时**不管选出0~15中的任何数量个，都可以由这4份组合出来(`二进制的理解`)**

这样上面的4份，每份要么选要么不选，显然成了一个新的01背包问题~用01背包的思路解决问题接口~重复`log a[i]`次01背包问题即可

但是上面的15正好可以拆分各位都是1的二进制，如果问题改成一个物品最多有12个可用，12的二进制是1100，按照上面的思路可以拆成1100，即8个和4个，这两个数并不能组成1~12之间所有的数

因此对于任何a[i]，我们都先拆成1个、2个、4个、...、$2^k$个、$a[i] - 2^k$ 个，k是满足$2^k-1 < n$的最大值。这种拆分就可以拼出0~a[i]内的任何值了(即多重背包选择i的个数)。比如12就可以拆分成1、2、4、5

通过上面的二进制拆分，对于一个最大可用数为a[i]的物品来说，我们就把它拆分了$log(a[i])$个只能用一次的物品，体积为$kc[i]$，价值为$kw[i]$，这样问题就变成了01背包问题，只是物品数量变成了$\sum_{i=1}^{N}log(a[i])$个，时间复杂度是O($V\sum_{i=1}^{N}log(a[i])$)
## 4.3 多重背包问题单调队列优化
> 上一节得到的多重背包问题的公式为：$dp[i][j] = max(dp[i - 1][j - k * c[i]] + k * w[i]  |  0 ≤ k * c[i] ≤ a[i])$，含义是第i个物品选k次，从剩余的i-1个物品中选取物品来满足容量$j - k * c[i]$的限制。遍历k的所有取值来找价值是多少
### 利用模和取余进行状态表达式简化
对于dp[i][j]（`从i个物品中选取物品填满容量为j的容器，其最大价值是dp[i][j]`）。k的范围受两个因素影响，一是a[i]表示k的上限，此外还要$ j - k * c[i] > 0$即$k < j / c[i]$，所以k的上限为两者的较小值，我们设物品个数为i是k的范围为b[i]，那么$b[i] = min(a[i], j / c[i])$

此时状态表达式变为：$$dp[i][j] = max(dp[i - 1][j - k * c[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$

下面观察dp[i][j]会从哪些状态转移过来：

对于$${ j - k * c[i] | 0 ≤ k ≤ b[i] }$$，$j - k * c[i]$模c[i]的余数都是相等的(因为k取不同的值结果都是差c[i]的整数倍)

我们令余数$mod = j % c[i]$，除数$div = j / c[i]$，那么j可以表示为$j = div * c[i] + mod$，替换dp[i][j]里面的j可以得到$$dp[i][j] = max(dp[i - 1][div * c[i] + mod - k * c[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$ $$= max(dp[i - 1][mod +  (div - k) * c[i]] + k * w[i] | 0 ≤ k ≤ b[i])$$

我们假设$k' = div - k$，因为 $0 ≤ k ≤ b[i]$，即$0 ≤ (div - k') ≤ b[i]$，移项可得$k'$的范围是$(div - b[i]) ≤  k' ≤ div$，k'带入上面的式子，可以得到$$dp[i][j] = max(dp[i - 1][mod + k' * c[i]] + (div - k') * w[i] | div - b[i] ≤  k' ≤ div)$$

把div * w[i] 单独拿出来，得到 $$dp[i][j] = max(dp[i - 1][mod + k' * c[i]] - k' * w[i] | (div - b[i]) ≤  k' ≤ div) + div * w[i]$$，这里k'批量换成k（就是个符号表示，和原来的k不是一个k），得到$$dp[i][j] = max(dp[i - 1][mod + k * c[i]] - k * w[i] | (div - b[i]) ≤  k ≤ div) + div * w[i]$$

考虑{mod, mod + c[i], mod + 2* c[i] + mod + 3 * c[i], ..., j}，可以知道dp[i][j]就是求j前面的$b[i]+1$(`为什么是b[i] + 1？因为b[i]是V/c[i]和a[i]的较小值，是真实的第i个物品选取个数的上限`)个数对应的$dp[i - 1][mod + k' * c[i]] - k' * w[i]$的最大值

对于最外层i的枚举，b[i]+ 1是固定的，因此问题转化为**求一个固定长度的滑窗内的最大值**，显然可以用单调队列来优化。

我们可以维护一个单调下降的队列，每次加入的时候加入到队尾，保证队头到队尾单调递减。每次弹出队头，直到满足队头在滑窗内，队头的值就是这个滑窗内的最大值，这样这一步就是线性的。

我们枚举mod，再枚举div，求dp[i][j]是用单调队列，总共是O(V)的，总的时间复杂度仍然保持在了O(NV)
## 4.4~4.7 知识精练