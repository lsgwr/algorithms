# 第06章 树状DP
> 树状动态规划
## 6.1 树状DP简介
### 基本介绍
状态图是一棵树，状态转移也发生在树上，父节点的值通过所有子节点的值得到，一般是在DFS过程中完成DP递推计算，伪代码如下：
```cpp
void dfs(u) {
    for v in u.child {
        dfs(v);
        use dp[v] to update dp[u]; // 递归回溯过程中更新
    }  
}
```
### 典例问题1 ：树上最长链
给定一棵树，每条边都有权，计算一条最长链，要求时间复杂度为O(n)

> 解决方案如下：

定义f[i]是以i为根的子树中的最长链。
+ 对于不经过i的路径：显然f[i] = max(f[i], f[j]) `j是i的子节点`
+ 对于经过i的路径，就需要选择两个子节点，把两个子节点往下走的最长路相加，再加上它们到i的路径和，去更新f[i]
  > 对于上面提到的最长路，定义g[i]表示从i往下走最远能走多远(即最长链)，$g[i] = max(g[i], g[j] + w(i, j))$ `其中j是i的子节点，为了获取g[j]需要进行DFS`，对于叶子节点f[i] = g[i] = 0

> 伪代码如下：

```cpp
void dfs(int u) {
    f[u] = g[u] = 0;
    int maxg1 = -1e9, maxg2 = -1e9;
    for(int v : u.children) { // v是u的子节点
        dfs(v); // 递归遍历子节点v，得到g[v]和f[v]，然后在下面的递归回溯过程中更新g[u]和f[u]
        g[u] = max(g[u], edge[u][v].weight + g[v]); // 根据u和v的权重加上dfs得到的g[v]来更新g[u]
        f[u] = max(f[u], f[v]); // 用子节点和当前节点的较长链来更新f[u]
        ...
        // 获取u的最长连长度排前二的两个子树
        if(g[v] + edge[u][v].weight > maxg1) {
            maxg2 = maxg1;
            maxg1 = g[v] + edge[u][v].weight;
        } else if(g[v] + edge[u][v].weight > maxg2) {
            maxg2 = g[v] + edge[u][v].weight;
        }
    }
    f[u] = max(f[u], maxg1 + maxg2);
}
```
我们从root开始进行DFS，最终的问题答案就是f[root]

### 典例问题1:`最大权值和`子树
给定一棵树，每个点都有权值(可正可负)。求一个子树，使得权值最大。要求时间复杂度为O(n)

设f[i]表示以i为根的子树中的最大权值和子树，为了方便转移，我们需要用新的一维表示是否选第i个点，f[i][1]表示选，f[i][0]表示不选
+ i选：$f[i][1] = w[i] + sum(max(0, f[j][1]) | j是i的子节点)$
+ i不选：$f[i][0] = max(0, max(max(f[j][0], f[j][1]) | j是i的子节点))$
  > i不选，其子树必然无法互相联通，因此只能遍历找到其所有子节点j所在子树的权值最大者

## 6.1~6.5 知识精练
### [HDU 1561 The more, The Better](http://acm.hdu.edu.cn/showproblem.php?pid=1561)
> 讲解：https://blog.csdn.net/harrypoirot/article/details/25426315

以树来存储各城堡之间的依赖关系。

首先说状态表示，dp[i][j]表示在以i为根节点的子树上攻破j个城堡可达到的最大收益。

为方便表示，以0号节点为总的根节点。

接下来使用‘背包九讲’中‘有依赖的背包问题’一节的思路来做。

‘有依赖的背包’是指要选某些物品，必须先选某件物品。这与本题恰好符合。

设j1号、j2号。。。jn号这n件物品依赖i号物品，那么可以将这n+1个物品归为一组，那么这n+1个物品可能有以下的取法：

```txt
只取第i号；
取第i号和第j1号；
取第i号和第j1、j2号；
取第i号和第j1、j2...jn号；

取第i号和第j2号；
取第i号和第j2、j3号；
......

...
取第i号和第jn号；
```

可是这种取法效率很低，很多多余情况。可以用01背包的方法来进行优化，即对这n+1种物品进行一次01背包，即可得出所有需要考虑的情况（具体参考‘背包九讲’）

不过因为i的第k个子节点jk也可能被jk的子节点所依赖，所以要通过dfs先把jk的工作做好再来处理i

> 代码实现如下：

```cpp
// 参考： https://blog.csdn.net/harrypoirot/article/details/25426315
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>

using namespace std;

vector<int> map[205];
int val[205], dp[205][205]; // dp[i][j]:以第i个节点为根节点，攻击子树中j个节点的最大获益
int n, m;

/**
 * @param root 当前的根节点 
 * @param c 需要在以root为根节点的子树中选取几个节点(即背包容量)
 */
void dfs(int root, int c) {
    int size = map[root].size(); // 获取依赖当前root节点其他节点
    dp[root][1] = val[root]; // 只攻击当前根节点一个节点
    for (int i = 0; i < size; ++i) { // 对于root的所有子节点做01背包（从root所有的子节点中选j个，背包容量为）
        if (c > 1) dfs(map[root][i], c - 1);
        // 若未到最后，则继续向下深搜,先算好将来所需的数据
        for (int j = c; j > 1; --j) { // 当背包容量为c时，j=1时为只选bg
            for (int k = 0; k <= j - 1; ++k) { // 攻击了第i个子节点下的k个节点,那么还剩下j-k次机会攻击其余的
                dp[root][j] = max(dp[root][j], dp[root][j - k] + dp[map[root][i]][k]);
            }
        }
    }
}

int main() {
    while (cin >> n >> m) {
        if (n == 0 && m == 0) break;

        memset(val, 0, sizeof(val));
        memset(dp, 0, sizeof(dp));
        for (int i = 0; i <= n; ++i) map[i].clear();
        int a, b;
        for (int i = 1; i <= n; ++i) {
            scanf("%d%d", &a, &b);
            // 设i1号、i2号...in号这n件物品依赖a号物品，那么可以将这些物品分为一组
            map[a].push_back(i); // a,b. 在第i行，a代表要攻克第i个城堡必须先攻克第a个城堡
            val[i] = b; // 第i个城堡的宝物价值是b
        }
        dfs(0, m + 1);//从‘0’开始进行DFS遍历，往下选m个，一共选m+1个
        cout << dp[0][m + 1] << endl;
    }
}
```
### [HDU 5593 ZYB's Tree](http://acm.hdu.edu.cn/showproblem.php?pid=5593)
> 题解：https://blog.csdn.net/Shili_Xu/article/details/82119452
```cpp
#include <cstdio>
#include <cstring>

using namespace std;
typedef long long ll;

const int MAXN = 5e5 + 5;

int t, n, k, a, b;
int fa[MAXN], sum[11];
int dp[MAXN][11];

int get(int u) {
    int ans = 0;
    memset(sum, 0, sizeof(sum));
    for (int i = 0, son = 0; u && i <= k; son = u, u = fa[u], i++) {
        sum[i]++;
        for (int j = 1; j <= k - i; j++) sum[i + j] += dp[u][j] - dp[son][j - 1];
    }
    for (int i = 0; i <= k; i++) ans += sum[i];
    return ans;
}

int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d %d %d %d", &n, &k, &a, &b);
        memset(dp, 0, sizeof(dp));
        fa[1] = 0;
        dp[1][0] = 1;
        for (int i = 2; i <= n; i++) {
            fa[i] = ((ll) a * i + b) % (i - 1) + 1;
            for (int u = i, j = 0; u && j <= k; u = fa[u], j++) dp[u][j]++;
        }
        int ans = 0;
        for (int i = 1; i <= n; i++) ans ^= get(i);
        printf("%d\n", ans);
    }
    return 0;
}
```
### [POJ 2486 Apple Tree](http://poj.org/problem?id=2486)
> 题解：

### [HDU 3586 Information Disturbing](http://acm.hdu.edu.cn/showproblem.php?pid=3586)
### [CodeForces 960E Alternating Tree](https://www.luogu.com.cn/problem/CF960E)
