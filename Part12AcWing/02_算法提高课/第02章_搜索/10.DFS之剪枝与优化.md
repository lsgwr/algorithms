# 10.DFS之剪枝与优化

## 搜索的常见剪枝策略：
+ 1）求最大值 or 最小值，一旦中间某种状态的值**大于已有的最小值**(`后续还会继续增大`)或者**小于已有的最大值**(`后续还会继续减少`)，则可以直接退出
+ 2）求方案数的问题，可以用记忆数组把每个方案的visited标记为true，这样下次访问到这种状态可以直接跳过


## 题目
### [AcWing 165.小猫爬山](https://www.acwing.com/problem/content/167/)
> 未剪枝的代码，和[AcWing 1118.分成互质组](09_DFS之搜索顺序.md#acwing-1118分成互质组) 完全一样的思路
```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车钟朗最多也就18个。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }
        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

> 剪枝：只要中间遍历到某个状态的缆车数多于前面得到过的缆车数，就可以提前退出了，再考虑更多的缆车数也没有意义了

其实就是加了一句`if (cableCnt >= res) return;`

```java
import java.util.*;

/**
 * 和 AcWing 1118.分成互质组 非常相似
 */
class Main {
    static int N; // 猫的数量
    static int W; // 缆车的数量
    static int[] weights; // 每只猫的重量
    static List<Integer>[] cables;

    static int res = 18; // 求最少的缆车数，那么要初始化为最大的缆车数
    static int cableCnt = 0; // 需要的缆车数，在DFS和回溯过程中动态更新

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // N只猫
        W = sc.nextInt(); // 每个缆车的上限
        weights = new int[N]; // 存储每个猫的重量
        for (int i = 0; i < N; i++) {
            weights[i] = sc.nextInt();
        }
        cables = new List[18]; // 最多18只猫，因为每个猫的重量都小于缆车，因此最多也就18个缆车。cables[i]表示第i辆缆车装了多少只猫
        for (int i = 0; i < 18; i++) {
            cables[i] = new ArrayList<>();
        }

        dfs(0);
        System.out.println(res);
    }

    // 枚举每一只猫属于哪一个缆车
    private static void dfs(int index) {
        if (index == N) { // 枚举完所有的猫了，统计一下当前使用的缆车数
            res = Math.min(res, cableCnt);
            return;
        }

        if (cableCnt >= res) return; // 如果现在的缆车数已经超过了前面最少地了，直接退出，核心的剪枝策略

        for (int i = 0; i < cableCnt; i++) {
            if (check(cables[i], index)) { // 计算把第index只猫加入第i个缆车后，缆车是否会超重
                cables[i].add(index); // 注意记录地是索引！
                dfs(index + 1); // 千万不要用index++，因为会改变index
                cables[i].remove(cables[i].size() - 1); // 回溯过程中删除之前加入的元素
            }
        }

        // 没有缆车能装下当前index对应的猫了，那么就需要新开一个缆车了
        cables[cableCnt].add(index);
        cableCnt++;
        dfs(index + 1);
        cableCnt--; // 回溯需要删去之前加地缆车，可以看出回溯前和回溯后，代码是对称地
        cables[cableCnt].remove(cables[cableCnt].size() - 1);
    }

    private static boolean check(List<Integer> cable, int index) {
        int sum = 0;
        for (int i : cable) {
            sum += weights[i];
        }
        return sum + weights[index] <= W;
    }
}
```

### [AcWing 166.数独](https://www.acwing.com/problem/content/168/)
> 自己的还没做完
```java
import java.util.*;

class Main {
    static char[][] grid;
    static int R = 9;
    static int C = 9;
    static int unPlacedCnt = 0; // 还没有放置好位置的元素
    static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {-1, 1}, {1, -1}};
    static final char[] chs = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};

    static boolean inGrid(int r, int c) {
        return r >= 0 && r < R && c >= 0 && c < C;
    }

    private static void dfs(int rCur, int cCur) {
        if (unPlacedCnt == 0) { // 所有没放置的位置都安排好了，直接返回即可
            return;
        }

        // 尝试填[rCur, cCur]周围的8个位置，不断往下递归
        for (int[] dir : dirs) {
            int rNext = rCur + dir[0];
            int cNext = cCur + dir[1];
            if (inGrid(rNext, cNext) && grid[rNext][cNext] != '.') { // 没防止过数字才能尝试占用
                List<Character> canPlaceList = place(rCur, cCur); // 尝试在当前位置防止1到9，满足条件的放到canPlaceList里
                for (char numChar : canPlaceList) { // 枚举当前位置可以放置的元素
                    grid[rNext][cNext] = numChar;
                    unPlacedCnt--;
                    dfs(rNext, cNext);
                    grid[rNext][cNext] = '.'; // 回溯过程中把放置的数字改回去
                    unPlacedCnt++; // 未放置的点个数+1
                }
            }
        }
    }

    /**
     * 在现有grid的情况下为了满足数独限制可以在位置(r, c)放置哪些字符
     */
    private static List<Character> place(int r, int c) {
        List<Character> result = new ArrayList<>();
        boolean[] visited = new boolean[256]; // 记录1~9这几个字符的放置情况
        // Todo：1.检查[r, c]所在行

        // Todo：2.检查[r, c]所在列

        // Todo：3.检查[r, c]所在的每个3 × 3的九宫格内
        return null;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = "";
        grid = new char[R][C];
        while (!(line = sc.nextLine()).equals("end")) {
            char[] lineChs = line.toCharArray();
            for (int i = 0; i < R * C; i++) {
                grid[i / C][i % R] = lineChs[i]; // 拆分成二维矩阵
                if (lineChs[i] == '.') unPlacedCnt++;
            }
            for (int r = 0; r < R; r++) {
                for (int c = 0; c < C; c++) {
                    if (grid[r][c] != '.') {
                        dfs(r, c); // 从已经填充的任何点开始DFS，找到方案了返回即可
                        break;
                    }
                }
            }
            // 输出grid即可
            for (int r = 0; r < R; r++) {
                for (int c = 0; c < C; c++) {
                    System.out.print(grid[r][c]); // 输出所有放置好后的字符
                }
            }
        }
    }
}
```
### [AcWing 167.木棒](https://www.acwing.com/problem/content/169/)
### [AcWing 168.生日蛋糕](https://www.acwing.com/problem/content/170/)