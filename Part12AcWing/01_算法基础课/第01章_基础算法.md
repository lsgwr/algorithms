# 第01章 基础算法

## 一.排序
### 1.快速排序
> 思想是分治，通过一趟排序将待排数组q[]分隔成独立的两部分，使得左半部分的数字均比右半部分的数字小...然后递归分别对这两部分数字继续进行排序...最终达到整个序列有序。`数组的左右边界分别是l和r`
+ ①确定分界点x
  > 一般有以下四种方法
  + 取左边界q[l]
  + 取右边界q[r]
  + 取中间数q[(l+r)/2]
  + 取随机数q[rand(l, r)]
+ ② 调整数组，使得≤x的数字都在x的左侧，≥x的数字都在x的右侧
  > 分界点的数字不一定是x。这一步是重点。很多题目经常考这个思想，如何优雅简单的实现很重要
  + 开辟两个指针i和j，i指向左边界，活动范围是[l, 分界点]；j指向右边界，活动范围是[分界点，r]
  + i不断右移，直到遇到一个数不小于x；j不断右移，直到遇到一个数不大于x
  + 交换i和j位置的元素
  + ...i和j继续往下走，直接i和j相遇，完成本轮调整
+ ③ 递归地按照①和②处理左右两边的区间数组

> 模板代码：
```java
static void quick_sort(int q[], int l, int r) {
    if(l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j) {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) {
            // swap(q[i], q[j]);
            int tmp = q[i];
            q[i] = q[j];
            q[j] = tmp;
        }
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```
之所以`i = l - 1, j = r + 1`而不是`i = l, j = r`是因为do..while上来会先执行一次

> 相关题目
+ `√`[785.快速排序](https://www.acwing.com/problem/content/787/)：时间复杂度O(nlogn)
    ```java
    import java.util.*;

    class Main {
        static void quick_sort(int q[], int l, int r) {
            if (l >= r) return;

            int i = l - 1, j = r + 1, x = q[l + r >> 1];
            while (i < j) {
                do i++; while (q[i] < x);
                do j--; while (q[j] > x);
                if (i < j) {
                    // swap(q[i], q[j]);
                    int tmp = q[i];
                    q[i] = q[j];
                    q[j] = tmp;
                }
            }
            quick_sort(q, l, j);
            quick_sort(q, j + 1, r);
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int[] q = new int[n];
            for (int i = 0; i < n; i++) q[i] = sc.nextInt();
            quick_sort(q, 0, n - 1);
            for (int i = 0; i < n; i++) System.out.print(q[i] + " ");
        }
    }
    ```
+ `√`[786.第k个数](https://www.acwing.com/problem/content/788/)：快速选择法，时间复杂度O(n)
    ```java
    import java.util.*;

    class Main {
        static int[] q;

        // 当前第k小的数肯定在q[l...r]中
        static int quick_select(int l, int r, int k) {
            if (l >= r) return q[l];

            int i = l - 1, j = r + 1, x = q[l + r >> 1];
            while (i < j) {
                do i++; while (q[i] < x);
                do j--; while (q[j] > x);
                if (i < j) {
                    // swap(q[i], q[j]);
                    int tmp = q[i];
                    q[i] = q[j];
                    q[j] = tmp;
                }
            }
            int sl = j - l + 1; // 小于x的元素数量(一次快速排序后位于左侧的元素)
            if (k <= sl) return quick_select(l, j, k); // 第k小元素在左半边
            else return quick_select(j + 1, r, k - sl); // 要找的第k小元素在右半边，因为左半边已经有sl个元素，所以在新的递归中要找第k-sl小元素
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int k = sc.nextInt();
            q = new int[n];
            for (int i = 0; i < n; i++) q[i] = sc.nextInt();
            System.out.println(quick_select(0, n - 1, k));
        }
    }
    ```

### 2.归并排序
> 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。它使用了递归分治的思想
+ ① 确定分界点 mid = (l + r) / 2
+ ② 递归，不断往下分成左右两部分
+ ③ 归并，即把当前的两个有序子序列合二为一
  > 设定两个指针i和j分别指向两个有序子序列，每次取i和j指向元素的较小值放到归并结果中，然后指针后移一位...直到两个子序列中的元素都归并到结果数组中就完成归并过程了
+ ④ 不断递归回退，把更大的两个子序列合并...直接到把整个数组排序好

> 模板代码
```cpp
static int[] tmp = new int[N]; // N为要排序地元素个数

// 当前第k小的数肯定在q[l...r]中
static void merge_sort(int q[], int l, int r) {
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (q[i] < q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];

    for (int m = l; m <= r; m++) q[m] = tmp[m - l];
}
```

> 练习题目
+ `√`[787.归并排序](https://www.acwing.com/problem/content/description/789/)
    ```java
    import java.util.*;

    class Main {
        static int[] q, tmp;

        // 当前第k小的数肯定在q[l...r]中
        static void merge_sort(int q[], int l, int r) {
            if (l >= r) return;

            int mid = l + r >> 1;
            merge_sort(q, l, mid);
            merge_sort(q, mid + 1, r);

            int k = 0, i = l, j = mid + 1;
            while (i <= mid && j <= r) {
                if (q[i] < q[j]) tmp[k++] = q[i++];
                else tmp[k++] = q[j++];
            }
            while (i <= mid) tmp[k++] = q[i++];
            while (j <= r) tmp[k++] = q[j++];

            for (int m = l; m <= r; m++) q[m] = tmp[m - l];
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            q = new int[n];
            tmp = new int[n];
            for (int i = 0; i < n; i++) q[i] = sc.nextInt();
            merge_sort(q, 0, n - 1);
            for (int i = 0; i < n; i++) System.out.print(q[i] + " ");
        }
    }
    ```
+ `√`[788.逆序对的数量](https://www.acwing.com/problem/content/790/)：这个题的思路很巧妙，好好看自己的打卡
    > 参考题解：https://www.acwing.com/solution/content/4737/
    ```java
    import java.util.*;

    class Main {
        static int[] q, tmp;

        // 当前第k小的数肯定在q[l...r]中
        static long merge_sort(int[] q, int l, int r) {
            if (l >= r) return 0;
            int mid = l + r >> 1;
            long res = merge_sort(q, l, mid) + merge_sort(q, mid + 1, r);

            int k = 0, i = l, j = mid + 1;
            while (i <= mid && j <= r) {
                if (q[i] <= q[j]) tmp[k++] = q[i++];
                else {
                    tmp[k++] = q[j++];
                    // 这一步是关键，前面的归并已经保证了q[i...mid]区间内的元素大于q[i]切且小于q[mid], 这些元素都会和q[j]组成逆序对。
                    res += mid - i + 1;
                }
            }
            while (i <= mid) tmp[k++] = q[i++];
            while (j <= r) tmp[k++] = q[j++];

            for (int m = l; m <= r; m++) q[m] = tmp[m - l];

            return res;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            q = new int[n];
            tmp = new int[n];
            for (int i = 0; i < n; i++) q[i] = sc.nextInt();
            System.out.println(merge_sort(q, 0, n - 1));
        }
    }
    ```

## 二.二分法
> 有单调性一定可以二分，但是可以二分不一定必须要有单调性
### 1.整数二分
> 记忆方法：要根据mid在左半区间还是在右半区间确定if分支的走向。核心不同是mid 等于 `l + r >> 1`还是`l + r + 1 >> 1`以及由此决定的if分支走向
```java
boolean check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：即mid在左半区间
int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：即mid在右半区间
int bsearch_2(int l, int r){
    while (l < r){
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

一般是先思考题目的check()函数，
+ 如果check规则是true时r = mid、false时l = mid + 1，那么mid就不用补上`+1`，即`int mid = l + r >> 1;`
+ 如果check规则是true时l = mid、false时r = mid - 1，那么mid就必须补上`+1`，即`int mid = l + r  + 1>> 1;`

> 题目如下：
+ `√`[789.数的范围](https://www.acwing.com/problem/content/description/791/)
    ```java
    import java.util.*;

    class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            int[] q = new int[n];
            for (int i = 0; i < n; i++) q[i] = sc.nextInt();
            while (m-- > 0) {
                int x = sc.nextInt();
                int l = 0, r = n - 1;
                while (l < r) {
                    int mid = l + r >> 1;
                    if (q[mid] >= x) r = mid;
                    else l = mid + 1;
                }
                if (q[l] != x) {
                    System.out.println("-1 -1");
                    continue;
                }
                System.out.print(l + " ");

                l = 0;
                r = n - 1;
                while (l < r) {
                    int mid = l + r + 1 >> 1;
                    if (q[mid] <= x) l = mid;
                    else r = mid - 1;
                }
                System.out.println(r);
            }
        }
    }
    ```

### 2.浮点数二分
```cpp
boolean check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch(double l, double r) {
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

题目如下：
+ `√`[790.数的三次方根](https://www.acwing.com/problem/content/description/792/)
    ```java
    import java.util.*;
    class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            double n, n_p;
            n = sc.nextDouble();
            n_p = Math.abs(n);
            double l = 0, r = n_p;
            // 保留6位时，精度应该计算到7位
            while (r - l > 1e-7) {
                double mid = (l + r) / 2;
                if (mid * mid * mid >= n_p) r = mid;
                else l = mid;
            }
            if (n > 0) System.out.printf("%.6f\n", l);
            else System.out.printf("%.6f\n", -l);
        }
    }
    ```

## 三、高精度
> 没有细了解，Java有自带的库~有空最好还是熟悉下
### 1.双高精度加法
```java
// C = A + B, A >= 0, B >= 0
static List<Integer> add(List<Integer> A, List<Integer> B) {
    if (A.size() < B.size()) return add(B, A);

    List<Integer> C = new ArrayList<>();
    int t = 0;
    for (int i = 0; i < A.size(); i++) {
        t += A.get(i);
        if (i < B.size()) t += B.get(i);
        C.add(t % 10);
        t /= 10;
    }

    if (t != 0) C.add(t);
    return C;
}
```
+ [791.高精度加法](https://www.acwing.com/problem/content/description/793/)
    ```java
    import java.util.*;

    class Main {
        // C = A + B, A >= 0, B >= 0
        static List<Integer> add(List<Integer> A, List<Integer> B) {
            if (A.size() < B.size()) return add(B, A);

            List<Integer> C = new ArrayList<>();
            int t = 0;
            for (int i = 0; i < A.size(); i++) {
                t += A.get(i);
                if (i < B.size()) t += B.get(i);
                C.add(t % 10);
                t /= 10;
            }

            if (t != 0) C.add(t);
            return C;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String a, b;
            List<Integer> A = new ArrayList<>();
            List<Integer> B = new ArrayList<>();
            a = sc.next(); // 假设a = "123456"
            b = sc.next();
            for (int i = a.length() - 1; i >= 0; i--) A.add(a.charAt(i) - '0'); // 此时A = [6, 5,4,3,2,1],高位也在索引大的位置
            for (int i = b.length() - 1; i >= 0; i--) B.add(b.charAt(i) - '0');
            List<Integer> C = add(A, B);
            for (int i = C.size() - 1; i >= 0; i--) System.out.print(C.get(i));
        }
    }
    ```

### 2.双高精度减法
```java
// C = A - B, 满足A >= B, A >= 0, B >= 0
static List<Integer> sub(List<Integer> A, List<Integer> B) {
    List<Integer> C = new ArrayList<>();
    for (int i = 0, t = 0; i < A.size(); i++) {
        t = A.get(i) - t; // t在这里的意思是借位
        if (i < B.size()) t -= B.get(i);
        C.add((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }
    while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
    return C;
}
```
+ [792.高精度减法](https://www.acwing.com/problem/content/description/794/)
    ```java
    import java.util.*;

    class Main {
        // 比较两个大数谁更大，方便后面用大的减去小的
        static boolean cmp(List<Integer> A, List<Integer> B) {
            if (A.size() != B.size()) return A.size() > B.size();
            // A和B长度相等地话
            for (int i = A.size() - 1; i >= 0; i--) {
                if (!A.get(i).equals(B.get(i))) return A.get(i) > B.get(i);
            }
            return true;
        }

        // C = A - B, 满足A >= B, A >= 0, B >= 0
        static List<Integer> sub(List<Integer> A, List<Integer> B) {
            List<Integer> C = new ArrayList<>();
            for (int i = 0, t = 0; i < A.size(); i++) {
                t = A.get(i) - t; // t在这里的意思是借位
                if (i < B.size()) t -= B.get(i);
                C.add((t + 10) % 10);
                if (t < 0) t = 1;
                else t = 0;
            }
            while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
            return C;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String a, b;
            List<Integer> A = new ArrayList<>();
            List<Integer> B = new ArrayList<>();
            a = sc.next(); // 假设a = "123456"
            b = sc.next();
            for (int i = a.length() - 1; i >= 0; i--) A.add(a.charAt(i) - '0'); // 此时A = [6, 5,4,3,2,1],高位也在索引大的位置
            for (int i = b.length() - 1; i >= 0; i--) B.add(b.charAt(i) - '0');
            List<Integer> C;
            if (cmp(A, B)) {
                C = sub(A, B);
            } else {
                C = sub(B, A);
                System.out.print("-");
            }
            for (int i = C.size() - 1; i >= 0; i--) System.out.print(C.get(i));
        }
    }
    ```

### 3.高精度乘低精度
```java
// C = A * b, A >= 0, b > 0
static List<Integer> mul(List<Integer> A, int b) {
    List<Integer> C = new ArrayList<>();

    int t = 0;
    for (int i = 0; i < A.size() || t != 0; i++) {
        if (i < A.size()) t += A.get(i) * b;
        C.add(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
    return C;
}
```
+ [793.高精度乘法](https://www.acwing.com/problem/content/795/)
    ```java
    import java.util.*;

    class Main {
        // C = A * b, A >= 0, b > 0
        static List<Integer> mul(List<Integer> A, int b) {
            List<Integer> C = new ArrayList<>();

            int t = 0;
            for (int i = 0; i < A.size() || t != 0; i++) {
                if (i < A.size()) t += A.get(i) * b;
                C.add(t % 10);
                t /= 10;
            }

            while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);

            return C;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String a, b;
            List<Integer> A = new ArrayList<>();
            List<Integer> B = new ArrayList<>();
            a = sc.next(); // 假设a = "123456"
            b = sc.next();
            for (int i = a.length() - 1; i >= 0; i--) A.add(a.charAt(i) - '0'); // 此时A = [6, 5,4,3,2,1],高位也在索引大的位置
            List<Integer> C = mul(A, Integer.parseInt(b)); // 大整数A乘以小整数b
            for (int i = C.size() - 1; i >= 0; i--) System.out.print(C.get(i));
        }
    }
    ```

### 4.高精度除以低精度
```cpp
static int r = 0; // 代表余数

// A / b = C ... r, A >= 0, b > 0
static List<Integer> div(List<Integer> A, int b) {
    List<Integer> C = new ArrayList<>();
    for (int i = A.size() - 1; i >= 0; i--) { // 对A从最高位开始处理
        r = r * 10 + A.get(i); // 将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
        C.add(r / b); // 所得即为商在这一位的数字
        r = r % b;
    }
    // 由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，
    // 因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0
    Collections.reverse(C);
    while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
    return C;
}
```
+ [794.高精度除法](https://www.acwing.com/problem/content/796/)
    ```java
    import java.util.*;

    class Main {
        static int r = 0; // 代表余数

        // A / b = C ... r, A >= 0, b > 0
        static List<Integer> div(List<Integer> A, int b) {
            List<Integer> C = new ArrayList<>();
            for (int i = A.size() - 1; i >= 0; i--) { // 对A从最高位开始处理
                r = r * 10 + A.get(i); // 将上次的余数*10在加上当前位的数字，便是该位需要除的被除数
                C.add(r / b); // 所得即为商在这一位的数字
                r = r % b;
            }
            // 由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，
            // 因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0
            Collections.reverse(C);
            while (C.size() > 1 && C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
            return C;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            String a;
            a = sc.next(); // 假设a = "123456"
            int b = sc.nextInt();
            List<Integer> A = new ArrayList<>();
            for (int i = a.length() - 1; i >= 0; i--) A.add(a.charAt(i) - '0'); // 此时A = [6, 5,4,3,2,1],高位也在索引大的位置
            List<Integer> C = div(A, b); // 大整数A乘以小整数b
            for (int i = C.size() - 1; i >= 0; i--) System.out.print(C.get(i));
            System.out.println();
            System.out.println(r);
        }
    }
    ```

## 四、前缀和与差分
### 1.前缀和
> 可以理解成一维dp和二维dp
+ [一维前缀和_参考博客](https://blog.csdn.net/qq_41661809/article/details/86727017)
+ [二维前缀和_参考博客](https://www.cnblogs.com/hulean/p/10824752.html)

> 题目如下：可以分别从一维坐标系和二维坐标系的图去理解

+ 一维前缀和 
  > [795.前缀和](https://www.acwing.com/problem/content/797/)
  + $S[i] = a[1] + a[2] + ... a[i] =\sum_{i=1}^{i}a[i]$
  + $a[l] + ... + a[r] =\sum_{i=l}^{r}a[i] = S[r] - S[l - 1]$
    ```java
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            // 初始化输入值
            Scanner in = new Scanner(System.in);
            int n = in.nextInt();
            int m = in.nextInt();
            int[] arr = new int[n + 1];
            // 注意这里是从 1开始的
            for (int i = 1; i <= n; i++) arr[i] = in.nextInt();
            // s[i]代表 arr的前 i项和
            int[] s = new int[n + 1];
            s[0] = 0;
            // 计算出 s[i]
            for (int i = 1; i <= n; i++) s[i] = s[i - 1] + arr[i]; // 注意运算方式

            // 循环输出
            while (m-- > 0) {
                int l = in.nextInt();
                int r = in.nextInt();
                System.out.println(s[r] - s[l - 1]);  // 关键
            }
        }
    }
    ```
+ 二维前缀和
  > [796.子矩阵的和](https://www.acwing.com/problem/content/798/)
  + S[i][j]表示(1,1)这个点与(i,j)这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，计算公式为：$S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j];$，这个公式的理解见[二维前缀和参考博客](https://www.cnblogs.com/hulean/p/10824752.html)
  + 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：$S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1]$
    ```java
    // 参考博客：https://www.cnblogs.com/hulean/p/10824752.html
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            // 初始化输入值
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt(), m = sc.nextInt(), q = sc.nextInt();
            int[][] a = new int[n + 1][m + 1];
            int[][] S = new int[n + 1][m + 1];
            // 读取a并计算S
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    a[i][j] = sc.nextInt();
                    // S[i - 1][j] + S[i][j - 1]多算了一个S[i - 1][j - 1]所以要减去
                    S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j];
                }
            }
            // 从S中查询区间
            while (q-- > 0) {
                int x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();
                System.out.println(S[x2][y2] - S[x1 - 1][y2] - S[x2][y1 - 1] + S[x1 - 1][y1 - 1]);
            }
        }
    }
    ```

### 2.差分
+ [一维差分_参考博客](https://www.cnblogs.com/MS903/p/11244969.html)
+ [二维差分_参考博客](https://www.cnblogs.com/LMCC1108/p/10753451.html)
+ [一维和二维差分_参考博客](https://www.acwing.com/solution/content/10946/)

> 题目如下：

+ 一维差分
  > [797.差分](https://www.acwing.com/problem/content/799/)
  + 差分：差分即相邻两个数的差。我们用一个数组p存储a的差分，那么p是a的差分数组，即`p[i]=a[i] - a[i - 1]`
  + 要给数组a加上c只需要`p[l] += k, p[r + 1]-=k;`
  + 输出每个a[i]时：`a[i] = p[i] + a[i-1];`
    ```java
    import java.io.*;
    import java.util.*;

    public class Main {
        // 插入操作函数
        public static void insert(int[] a, int l, int r, int c) {
            a[l] += c;
            a[r + 1] -= c;
        }
        
        public static void main(String[] args) {
            Scanner sc = new Scanner(new BufferedInputStream(System.in));
            int n = sc.nextInt(), m = sc.nextInt();
            //a为原数组，b为差分数组
            int[] a = new int[n + 2];
            int[] b = new int[n + 2];

            for (int i = 1; i <= n; i++) a[i] = sc.nextInt();
            //进行n次插入，初始化差分数组
            for (int i = 1; i <= n; i++) insert(b, i, i, a[i]);

            while (m-- > 0) {
                int l = sc.nextInt(), r = sc.nextInt(), c = sc.nextInt();
                insert(b, l, r, c);
            }
            //经过一系列插入操作后，现在答案数组应该是b数组的前缀和，让b数组变成b的前缀和。
            //公式 b[i] = b[i-1] + b[i] 
            for (int i = 1; i <= n; i++) b[i] += b[i - 1];
            for (int i = 1; i <= n; i++) System.out.print(b[i] + " ");
        }
    }
    ```
+ 二维差分
  > [798.差分矩阵](https://www.acwing.com/problem/content/description/800/)
  + 计算差分,a是原始数组，p是差分数组：$p[i][j] = a[i][j] - a[i][j - 1] - a[i - 1][j] + a[i - 1][j - 1];$
  + 在(x1, y1)到(x2, y2)的区间上都加上c：$p[x1][y1] += c, p[x2 + 1][y1] -= c, p[x1][y2 + 1] -= c, p[x2 + 1][y2 + 1] += c;$
  + 更新a[i]: `a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + p[i][j];`
    ```java
    // 参考：https://www.acwing.com/solution/content/10946/
    import java.io.*;

    public class Main {
        // 插入操作函数
        static void insert(int[][] b, int x1, int y1, int x2, int y2, int k) {
            b[x1][y1] += k;
            b[x2 + 1][y1] -= k;
            b[x1][y2 + 1] -= k;
            b[x2 + 1][y2 + 1] += k;
        }
        
        public static void main(String[] args) throws IOException {
            //普遍Scanner会超时，所以使用BufferedReader
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out)); 
            String[] str1 = reader.readLine().split(" ");

            int n = Integer.parseInt(str1[0]);
            int m = Integer.parseInt(str1[1]);
            int q = Integer.parseInt(str1[2]);
            int[][] a = new int[n + 2][m + 2];
            int[][] b = new int[n + 2][m + 2];

            for (int i = 1; i <= n; i++) {
                String[] str2 = reader.readLine().split(" "); // 读入原数组
                for (int j = 1; j <= m; j++) {
                    a[i][j] = Integer.parseInt(str2[j-1]);
                    insert(b, i, j, i, j, a[i][j]); // 初始化差分数组
                }
            }


            while (q-- > 0) {
                String[] str3 = reader.readLine().split(" ");
                int x1 = Integer.parseInt(str3[0]);
                int y1 = Integer.parseInt(str3[1]);
                int x2 = Integer.parseInt(str3[2]);
                int y2 = Integer.parseInt(str3[3]);
                int k  =  Integer.parseInt(str3[4]);
                insert(b, x1, y1, x2, y2, k);
            }

            // 求b数组的前缀和
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= m; j++) {
                    b[i][j] += b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1];
                    writer.write(b[i][j] + " ");
                }
                writer.write("\n");
            }
            //所有write下的内容，会先存在writers中，当启用flush以后，会输出存在其中的内容。如果没有调用flush，则不会将writer中的内容进行输出。
            writer.flush();
            reader.close();
            writer.close();
        }
    }
    ```

## 五、双指针法
> 双指针法有时也叫快慢指针，在数组里是用两个整型值代表下标，在链表里是两个指针，一般能实现O（n）的时间解决问题，两个指针的位置一般在`第一个元素和第二个元素`(相同方向)或者`第一个元素和最后一个元素`(相反方向)，快指针在前“探路”，当符合某种条件时慢指针向前挪。时间复杂度是`O(n)`
### 参考博客
+ [LeetCode刷题总结之双指针法](https://www.cnblogs.com/codingstory/p/11334827.html)
+ [双指针法的常见应用](https://blog.csdn.net/ohmygirl/article/details/7850068)

### 代码模板
```cpp
for (int i = 0, j = 0; i < n; i++) {
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
```

### 常见问题分类：
+ (1) 对于一个序列，用两个指针维护一段区间
+ (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

### 实战
+ [AcWing 799.最长连续不重复子序列](https://www.acwing.com/problem/content/description/801/)
    ```java
    import java.util.*;

    public class Main {
        public static void main (String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int [] a = new int[n];
            Map<Integer, Integer> map = new HashMap<>();

            for (int i = 0; i < n; i++) a[i] = sc.nextInt();

            int res = 0;
            for (int i = 0, j = 0; i < n; i++) {
                map.put(a[i], map.getOrDefault(a[i], 0) + 1); //如果没有放入则设为0
                while (map.get(a[i]) > 1) { 
                    //按照模版，while中进行j++的循环
                    map.put(a[j], map.get(a[j]) - 1);
                    j++;
                }
                res = Math.max(res, i - j + 1);
            }
            System.out.println(res);
        }
    }
    ```
+ [AcWing 800.数组元素的目标和](https://www.acwing.com/problem/content/description/802/)
    ```java
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt(), m = sc.nextInt(), x = sc.nextInt();
            int[] a = new int[n];
            int[] b = new int[m];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            for (int i = 0; i < m; i++) b[i] = sc.nextInt();
            int[] res = sum(a, b, x);
            System.out.println(res[0] + " " + res[1]);
        }

        private static int[] sum(int[] a, int[] b, int x) {
            int j = b.length - 1;
            for (int i = 0; i < a.length; i++) {
                while (j >= 0 && a[i] + b[j] > x) j--;
                if ((a[i] + b[j]) == x) return new int[]{i, j};
            }
            return new int[2];
        }
    }
    ```

## 六、位运算
### 0.基本概念
| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移） |
### 1.常用的位运算
+ 1.判断奇偶(x%2==1) ：`x & 1 ==1 OR ==0`
+ 2.清零最低位的1 ： `x = X & (X -1)`
+ 3.得到最低位的1：`x & -x`
+ 4.将x最右边的n位清零 `x & (~0 << n)`
+ 5.获取x的第n位值(0或者1) `(x >> n) & 1`
+ 6.获取x的第n位的幂值 `x & (1 << (n-1))`
+ 7.仅将第n位 置为1 `x | ( 1 << n )`
+ 8.仅将第n位 置为0 `x & (~( 1 << n ))`
+ 9.将x最高位至第n位(含)清零 `x & ((1<<n) - 1)`
+ 10.将第n位至第0位(含)清零 `x & (~((1 << (n+1)) - 1))`

最常用的两个是：
+ 1.求n的第k位数字: `n >> k & 1`
  + `n >> k`表示把n的二进制表示的第k位移到最后
  + `& 1`表示把最后一位二进制数字取出来
  + 上面两步结合起来就实现了取出n的二进制表示的第k位
+ 2.返回n的最后一位1：`lowbit(n) = n & -n`，如`10100`，则lowbit函数返回`100`。
  > `n & -n`等效于`n & (~n + 1)`，自己好好理解下

### 2.典型题目
+ [AcWing 801. 二进制中1的个数](https://www.acwing.com/problem/content/803/)
    ```java
    import java.util.Scanner;

    public class Main {
        static int lowbit(int x) {
            return x & -x;
        }

        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            while (n-- > 0) {
                int x = sc.nextInt();
                int res = 0;
                while (x != 0) {
                    x -= lowbit(x); // 每次减去x的最后一位1，直到x变成0，循环了多少次就有多少个1
                    res++;
                }
                System.out.print(res + " ");
            }
        }
    }
    ```

## 七、离散化
### 1.基本概念
离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。

但是离散化仅适用于`只关注元素之间的大小关系而不关注元素本身的值`!这句话的理解非常重要。简单说就是把大下标转化成小下标，但是相对的大小关系不变~~

### 2.步骤：
+ 1).将所有需要离散化的数据（如下面例子中的下标）放到一个容器中（以下使用vector，当然可以用数组代替）；
+ 2).排序，去重（可以手写，也可以用STL的algorithm库中的unique函数）
+ 3).要查询原数据在容器中的位置只需在容器中二分查找第一个大于等于该数据的数的位置即可
### 3.模板代码
```cpp
Set<Integer> set = new TreeSet<>(); // 存储所有待离散化的值，添加后会自动排序和去重
// 二分求出x对应的离散化的值，即找到第一个大于等于x的位置
static int findIndex(int[] mapping, int target) {
    int l = 0;
    int r = mapping.length - 1;
    while (l + 1 < r) {
        int mid = l + (r - l) / 2;
        if (mapping[mid] < target) l = mid;
        else r = mid;
    }
    return mapping[l] == target ? l : r;
}
```

### 4.相关题目
+ [AcWing 802.区间和](https://www.acwing.com/problem/content/804/)
    ```java
    import java.io.*;
    import java.util.*;

    public class Main {
        public static void main(String[] args) throws IOException {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            String[] line0 = reader.readLine().split(" ");
            int n = Integer.parseInt(line0[0]);
            int m = Integer.parseInt(line0[1]);
            Set<Integer> set = new TreeSet<>();
            int[] indexes = new int[n];  // 保存了所有的x
            int[] operate = new int[n];  // 保存了所有的c
            for (int i = 0; i < n; i++) {
                String[] line = reader.readLine().split(" ");
                int x = Integer.parseInt(line[0]);
                int c = Integer.parseInt(line[1]);
                indexes[i] = x;
                operate[i] = c;
                set.add(x);
            }
            int[] queryLeft = new int[m];  //保存了所有的l
            int[] queryRight = new int[m]; //保存了所有的r
            for (int i = 0; i < m; i++) {
                String[] line = reader.readLine().split(" ");
                int l = Integer.parseInt(line[0]);
                int r = Integer.parseInt(line[1]);
                queryLeft[i] = l;
                queryRight[i] = r;
                set.add(l);
                set.add(r);
            }
            // 现在set里面已经有了排好序的去了重的所有坐标，开始对坐标进行离散化
            int[] mapping = new int[set.size()];
            int k = 0;
            for (int e : set) mapping[k++] = e;

            // 开始对离散化后的数组进行操作 利用之前保存的x(indexes数组中)找到离散化后的数组位置进行操作(操作保存在了operate数组中)
            int[] afterOpMapped = new int[set.size()];
            // 构造差分 (starts with index of 0), afterOpMapped就是原数轴操作完后离散化的映射
            for (int i = 0; i < n; i++) {
                int index = findIndex(mapping, indexes[i]);
                afterOpMapped[index] += operate[i];
            }

            // 构造前缀和 (starts with index of 1;)
            int[] preSum = new int[mapping.length + 1];
            for (int i = 1; i <= afterOpMapped.length; i++) preSum[i] = afterOpMapped[i - 1] + preSum[i - 1];

            // 完成询问  所有针对原数轴的循环全部转换成对离散化映射数组的询问。
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < m; i++) {
                int l = findIndex(mapping, queryLeft[i]) + 1;
                int r = findIndex(mapping, queryRight[i] + 1);
                sb.append(preSum[r] - preSum[l - 1]);
                sb.append("\n");
            }
            sb.deleteCharAt(sb.length() - 1);
            System.out.println(sb.toString());
        }

        public static int findIndex(int[] mapping, int target) {
            int l = 0;
            int r = mapping.length - 1;
            while (l + 1 < r) {
                int mid = l + (r - l) / 2;
                if (mapping[mid] < target) l = mid;
                else r = mid;
            }
            return mapping[l] == target ? l : r;
        }
    }
    ```

### 5.参考博客
+ [离散化](https://blog.csdn.net/S_999999/article/details/99080549)
+ [AcWing 802.区间和分析过程](https://www.acwing.com/solution/content/6055/)

## 八、区间合并
### 1.步骤
+ 1) 按照区间左端点排序：为什么这么做，实际涉及到贪心，参考[LeetCode上的一篇题解](https://leetcode-cn.com/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/)
+ 2) 如图所示，可分3种情况进行处理
  > ![区间的三种情况](https://cdn.acwing.com/media/article/image/2019/11/05/7416_34dd0006ff-2df0af743fbf357f2e071728365db89.png)
  + 情况一：当前区间完全被上一区间覆盖，直接跳过
  + 情况二：将当前区间的右端点更新为上一区间的右端点，达到区间延长的效果
  + 情况三：当前区间的左端点严格大于上一区间的右端点，则表示该区间不能合并(因为前面已经按照区间左端点排序了)，更新区间且count++

### 2.代码模板
```java
// 这个静态类很通用
static class PII implements Comparable<PII> {
    int first;
    int second;

    public PII(int first, int second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public int compareTo(PII o) {
        return first - o.first;
    }
}

static List<PII> merge( List<PII> segs) {
    List<PII> res = new ArrayList<>();
    Collections.sort(segs); // 先对区间按照左端点进行排序
    
    int st = Integer.MIN_VALUE, ed = Integer.MIN_VALUE; // 区间的左端点和右端点
    for (PII seg : segs) {
        if (ed < seg.first) {// 当前区间的右端点 < 下一个区间的左端点，则当前区间不需要进行合并处理了
            if (st != Integer.MIN_VALUE) res.add(new PII(st, ed));
            st = seg.first;
            ed = seg.second;
        } else {
            // 当前区间的右端点≥下一个区间的左端点，则需要合并两个区间，取两个区间右端点的较大者
            ed = Math.max(ed, seg.second); 
        }
    }
    if(st != Integer.MIN_VALUE) res.add(new PII(st, ed));
    return res;
}
```

### 3.题目
+ [803.区间合并](https://www.acwing.com/problem/content/description/805/)

### 4.完整代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }
    
    static List<PII> merge( List<PII> segs) {
        List<PII> res = new ArrayList<>();
        Collections.sort(segs); // 先对区间按照左端点进行排序
        
        int st = Integer.MIN_VALUE, ed = Integer.MIN_VALUE; // 区间的左端点和右端点
        for (PII seg : segs) {
            if (ed < seg.first) {// 当前区间的右端点 < 下一个区间的左端点，则当前区间不需要进行合并处理了
                if (st != Integer.MIN_VALUE) res.add(new PII(st, ed));
                st = seg.first;
                ed = seg.second;
            } else {
                // 当前区间的右端点≥下一个区间的左端点，则需要合并两个区间，取两个区间右端点的较大者
                ed = Math.max(ed, seg.second); 
            }
        }
        if(st != Integer.MIN_VALUE) res.add(new PII(st, ed));
        return res;
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        System.out.println(merge(list).size());        
    }
}
```