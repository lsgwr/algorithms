# 第06章 贪心算法
## 一、区间选点
> 题目链接：https://www.acwing.com/problem/content/description/907/

### 做法
+ 1.将每个区间按照右端点从小到大进行排序
+ 2.从前往后枚举每个区间，初始选定end值为无穷小
  + 2.1 若当前区间中包含该点end，则直接跳过
  + 2.2 否则，选择当前区间的右端点

### 贪心性质证明
+ 1.找到cnt个点，满足题意情况，则最优解$ans <= cnt$
+ 2.找到cnt个点，即找到cnt个区间，且区间从左到右依次排好且没有相同的交集(`一旦有两个区间有交集，那么至少有两个cnt的点可以合并成一个`)，则说明可能有区间没有被这cnt个点覆盖过，所以最优解$ans >= cnt$
+ 3.即$and == cnt$，证明完毕

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```

### 类似的题目：[803 区间合并](https://www.acwing.com/problem/content/description/805/)

## 二、最大不相交区间数量
> 题目链接：https://www.acwing.com/problem/content/910/
### 题目分析
> 最大不相交区间数==最少覆盖区间点数

为什么最大不相交区间数==最少覆盖区间点数呢？

因为如果几个区间能被同一个点覆盖，说明他们相交了，所以有几个点就是有几个不相交区间

因此本题的代码和上面那个题的代码完全一致

### 代码是和上面的题目完全相同
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return second - o.second;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list);
        int count = 0;
        int end = Integer.MIN_VALUE / 2;
        for (PII pii : list) {
            if (pii.first > end) {
                count++;
                end = pii.second;
            }
        }
        System.out.println(count);
    }
}
```

## 三、区间分组
> 题目链接：https://www.acwing.com/problem/content/description/908/
### 算法分析

+ 1、将所有区间按左端点从小到大排序
+ 2、从前往后枚举每个区间，判断能否将其放到某个现有的组中，即是否存在当前区间的的左端点L > 所有组中所有右端点的最大值max_r中的最小值(`所有分组内的max_r的最小值`)
  + 2.1 如果不存在这样的组(`即l <= max_r，说明当前区间和最小的max_r对应的分组有区间重叠`)，则开新组，然后再将其放进组中()
  + 2.2 如果存在这样的组，则将其放在符合条件的组中，并更新当前组的右端点的值(`删除原来最小堆堆顶元素并把当前区间右端点加进去`)
+ 3、为了不用每次选择组时都遍历所有组，可以通过小根堆来维护所有组中的`尾端(max_r)`

### 证明：
+ 1、按照上述存放，一定是一种合法的方案，则ans <= cnt
+ 2、由于分了cnt个组，则说明一定存在cnt个区间含有公共点，则一定至少开cnt个组，则ans >= cnt
+ 3、综合1、2可推出Ans == cnt

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        Collections.sort(list); // 按照左端点进行排序
        Queue<Integer> pq = new PriorityQueue<>(); // 维护已合并区间的右端点，堆顶元素是最小值
        for (PII pii : list) {
            // 存在使得 当前区间的的左端点L > 任意组中右端点的最小值 的组，则更新最小堆
            if (!pq.isEmpty() && pii.first > pq.peek()) pq.remove();
            pq.add(pii.second);
        }
        System.out.println(pq.size());
    }
}
```

## 四、区间覆盖
> 题目链接：https://www.acwing.com/problem/content/909/
### 算法解析
+ 1、将所有区间按左端点从小到大进行排序
+ 2、从前往后枚举每个区间，在所有能覆盖start的区间中，选择右端点最大的区间，然后将start更新成右端点的最大值

### 证明
在剩下所有能覆盖start的区间中，选择右端点最大的区间，则一定会比前面的选择最优，更快达到end，所以该做法一定是最优

### 时间复杂度 O(nlogn)

### 代码实现
```java
import java.util.*;

public class Main {
    static class PII implements Comparable<PII> {
        int first;
        int second;

        public PII(int first, int second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public int compareTo(PII o) {
            return first - o.first;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int start = sc.nextInt();
        int end = sc.nextInt();
        int n = sc.nextInt();
        List<PII> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(new PII(sc.nextInt(), sc.nextInt())); // 根据左右端点创建PII对象
        }
        int res = 0;
        Collections.sort(list); // 按照左端点进行排序
        for (int i = 0; i < list.size(); i++) {
            int j = i; // 所有能覆盖start的区间中，右端点最大的区间
            int r = Integer.MIN_VALUE; // 标识是否可以完全覆盖
            // 在现有所有区间中所有可能覆盖start的区间中找到最大的又端点
            // 说可能是因为list.get(j).first <= start还可能list.get(j).second <= start导致当前区间覆盖不了start
            // 我们这里可以先考虑所有可能覆盖start的区间，利用j++把这些可能区间的最右端点算出来，最后判断下r和start的关系
            // 如果r < start，说明所有的区间都完整地再start左侧，无解；否则覆盖了start，就继续往后遍历去看下能不能覆盖到end
            while (j < n && list.get(j).first <= start) {
                r = Math.max(r, list.get(j).second);
                j++;
            }
            // 循环到最后还不能覆盖start，说明所有的区间都完整地再start左侧，即无解
            if(r < start) { 
                System.out.println(-1);
                return;
            }
            // 能覆盖start，对区间计数+ 1
            res++;
            // 已经到了覆盖start且到end了，退出并输出区间个数即可
            if (r >= end) { 
                System.out.println(res);
                return;
            }
            // 更新start为，继续往后找
            start = r; // 更新下一轮遍历的起始位置
            i = j - 1; // j-1是因为j可能已经超过end了
        }
        System.out.println(-1); // 没能在上面找到，本身就说明没路径了，输出-1即可
    }
}
```

## 五、果子合并
> 题目链接：https://www.acwing.com/problem/content/150/

### 联想：与`石子合并`题目进行比较
看起来和[石子合并](https://www.acwing.com/problem/content/284/)差不多，其实不同如下：
+ `石子合并`只能相邻两个合并
+ `果子合并`可以任意两个合并

> 因此前者只能用区间DP，后者也可以用DP，但是后者用DP肯定会超时，只能过`1/10`个用例，因此后者只能用贪心

### 算法解析
> (贪心,哈夫曼树,堆,优先队列) $O(nlogn)$

看成是一棵树，最后合并成一个节点。

完全二叉树，所有的叶子节点就是要合并的点。

内部点就是合并过来的点。

每个叶子节点会被算几次，看看这个叶子节点有几个父节点就会被算几次。

这道题的本质，`一共有多个完全二叉树，看看哪个完全二叉树的叶子节点的权值总和最小，把它输出来。`

这是经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。直接用Java自带的优先队列即可

本题结合Huffman树的讲解为[贪心——Huffman树](https://www.jianshu.com/p/0d1cbb1f394b)

### 时间复杂度
> 使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。

每次操作会将果子的堆数减一，一共操作$n−1$次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是$O(logn)$。因此总时间复杂度是 $O(nlogn)$

### 代码实现
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Queue<Integer> pq = new PriorityQueue<>();
        while(n-- > 0) {
            pq.add(sc.nextInt());
        }
        int res = 0;
        // 每次弹出堆中的两个最小值，合并后再压入回去
        while(pq.size() > 1){
            int m = pq.remove() + pq.remove(); // 弹出两个最小值进行合并
            pq.add(m); // 新结果加入
            res += m; // 代价累计
        }
        System.out.println(res);
    }
}
```

## 六、排队打水
### 算法分析
安排他们的打水顺序才能使所有人的等待时间之和最小，则需要将打水时间最短的人先打水

### 证明：
不妨设
+ (1)$i_1 ≠ i_2 ≠ i_3 ≠ … ≠ i_n$
+ (2)$i_1$~$i_n$属于[1,n]
+ (3)$t_1 < t_2 < t_3 <… < t_n$

+ 1、由`i`的任意性，打水的时间总和为$t_i_1$ * $(n - 1) + ti_2 * (n - 2) + … + tin * (n - n) =n * (ti1 + ti2 +… + tin) - (ti1 * 1 + ti2 * 2 + … + tin * n)$

2、即相当于求 ti1 * 1 + ti2 * 2 + … + tin * n 的最大值

3、假设ti1 , ti2 ,… , tin是按自然顺序排好序时是最大值，即Tmax = t1 * 1 + t2 * 2 + … + tn
4、任意选择两项ta∗x,tb∗(x+c),且ta < tb,c > 0,交换ta,tb位置得到tb∗x,ta∗(x+c) ,同时交换后不会对其他项造成影响
由于ta * x + tb * (x + c) = ta * x + tb * x + tb * c > ta * x + tb * x + ta * c = tb * x + ta * (x + c),即交换之后比原来的值更小.由于选取的任意性可得假设成立.

时间复杂度 O(nlogn)