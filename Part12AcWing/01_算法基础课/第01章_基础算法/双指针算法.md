# 双指针算法

## 常见题目类型
> 一共3种，如下

+ 快慢指针
+ 左右指针
+ 滑动窗口

## 口诀
> 来自labuladong

**链表指针数组题**，用双指针别犹豫。  
双指针家三兄弟，各个都是万人迷。  

**快慢指针**最神奇，链表操作无压力。  
归并排序找中点，链表成环搞判定。  

**左右指针**最常见，左右两端相向行。  
反转数组要靠它，二分搜索是弟弟。

**滑动窗口**老猛男，子串问题全靠它。  
左右指针滑窗口，一前一后齐头进。

## 参考两篇不错的文章
> 备份一份到当前目录吧

+ [我写了套框架，把双指针算法变成了默写题](https://blog.csdn.net/fdl123456/article/details/105697625/)
+ [双指针技巧汇总](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw%3D%3D&chksm=9bd7fa51aca07347009c591c403b3228f41617806429e738165bd58d60220bf8f15f92ff8a2e&idx=1&mid=2247484505&scene=21&sn=0e9517f7c4021df0e6146c6b2b0c4aba#wechat_redirect)
  > 这篇文档在微信里不方便看，找到了一篇CSDN上转载的[双指针技巧汇总(转)](https://blog.csdn.net/xxdddail/article/details/93735314)

## 1、快慢指针
> 主要解决链表中的问题，比如判定链表中是否包含环。快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。

### 1.1 应用1：判定链表中是否含有环
这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。

单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。

如果链表中不包含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。
```java
boolean hasCycle(ListNode head) {
    while (head != null) head = head.next;
    return false;
}
```
但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。

经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

```java
boolean hasCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while(fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) return true;
    }
    return false;
}
```

### 1.2 应用2：已知链表中有环，返回这个环的起始位置
![已知链表中含有环，返回这个环的起始位](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075016458-1495003044.jpg)

这个问题其实不困难，有点类似脑筋急转弯，先直接看代码：
```java
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    
    slow = head;
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

可以看到，当快慢指针相遇时，让其中任一个指针重新指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？

第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。

![k与2k](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075054000-1816921447.jpg)

设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。

![slow和falst都移动k-m](https://img2018.cnblogs.com/blog/1566782/201906/1566782-20190626075122685-698940711.jpg)

所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。

## 二、左右指针
> 主要解决数组(或者字符串)的问题，比如二分查找。

