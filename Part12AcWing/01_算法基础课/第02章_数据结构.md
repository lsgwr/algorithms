# 第2章 数据结构
> 这一章的KMP和哈希不是很熟，需要再多看看
## 1.链表
### 1.1 单链表
+ [826.单链表](https://www.acwing.com/problem/content/828/)
    ```java
    // 参考：https://www.acwing.com/solution/content/4751/
    import java.io.*;

    public class Main {
        static int N = 100010;  // 数据规模为 10w

        static int head;                // 表示头结点的下标
        static int[] e = new int[N];    // 表示结点 i的值
        static int[] ne = new int[N];   // 表示结点 i的 next指针是多少
        static int idx;                 // 表示存储当前结点已经使用结点的下一个结点

        // 初始化数据
        static void init() {
            head = -1;  // 没有头结点
            idx = 0;    // 没有存入数据
        }

        // 将 val插到头结点
        static void addToHead(int val) {
            e[idx] = val;   // 赋值
            ne[idx] = head; // 插入之前头结点的前面
            head = idx;     // 更新头结点信息
            idx++;          // idx向右移动
        }

        // 将下标是 k的点后面的点删掉
        static void remove(int k) {
            ne[k] = ne[ne[k]];  // 让下标为 k的结点指向 下个结点的下个结点
        }

        // 将 val插入下标为 k的点的后面
        private static void add(int k, int val) {
            e[idx] = val;
            ne[idx] = ne[k];
            ne[k] = idx;
            idx++;
        }

        public static void main(String[] args) throws IOException {
            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            int m = Integer.parseInt(reader.readLine());
            init(); 
            // 进行 m次操作
            while (m-- > 0) {
                String[] s = reader.readLine().split(" ");
                if (s[0].equals("H")) {  // 插入头结点操作, 不能使用 ==, 要使用 equals()
                    int val = Integer.parseInt(s[1]);
                    addToHead(val);
                } else if (s[0].equals("I")) {   // 普通插入操作
                    int k = Integer.parseInt(s[1]);
                    int val = Integer.parseInt(s[2]);
                    add(k - 1, val);    // 第 k个结点的下标为 k-1, 所以插入到下标为 k-1结点的后面
                } else {    // s[0] == "D", 删除操作
                    int k = Integer.parseInt(s[1]);
                    if (k == 0) head = ne[head]; // 题意: k = 0, 删除头结点
                    else remove(k - 1);  // 第 k个结点的下标为 k-1, 所以是删除到下标为 k-1后面的后面
                }
            }
            for (int i = head; i != -1; i = ne[i]) System.out.print(e[i] + " ");
        }
    }
    ```


### 1.2 双链表
+ [827.双调表](https://www.acwing.com/problem/content/829/)
```java
/**
 * 参考链接：https://www.acwing.com/solution/content/13843/
 * 注意点：
 *   1.往最后端点插入时，可以用l[1],即最后一个位置的左节点来确定
 *   2.同样，往一个点左边插入时，需要的也是l[k]
 *   3.初始化操作：r[0]=1; l[1]=0; idx=2; head和tail分别为下标0和1
 *   4.int t=0;
 *     while(r[t]!=1){t=r[t];}
 *     add(t,x);
 *     // 这种方式取尾节点的时间最差为1e9，时间会爆掉=100000^2
 */

import java.util.*;

class Main {
    static int N = 100010;
    static int idx = 0;
    static int[] e = new int[N];
    static int[] l = new int[N];
    static int[] r = new int[N];

    public static void init() {
        r[0] = 1;
        l[1] = 0;
        idx = 2;
    }

    //在idx为k后加入一个节点
    public static void add(int k, int x) {
        e[idx] = x;
        r[idx] = r[k];
        l[idx] = l[r[k]];
        l[r[k]] = idx;
        r[k] = idx;
        idx++;
    }

    //删除idx为k的节点
    static void remove(int k) {
        l[r[k]] = l[k];
        r[l[k]] = r[k];
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        init();
        while (n-- > 0) {
            String c = sc.next();
            int k, x;
            if (c.equals("L")) {
                x = sc.nextInt();
                add(0, x);
            } else if (c.equals("R")) {
                x = sc.nextInt();
                add(l[1], x);
            } else if (c.equals("D")) {
                k = sc.nextInt();
                remove(k + 1);
            } else if (c.equals("IL")) {
                k = sc.nextInt();
                x = sc.nextInt();
                add(l[k + 1], x);
            } else if (c.equals("IR")) {
                k = sc.nextInt();
                x = sc.nextInt();
                add(k + 1, x);
            }
        }
        for (int i = 0; r[i] != 1; i = r[i]) System.out.print(e[r[i]] + " ");
    }
}
```
## 2.栈
### 2.1 普通栈
+ [AcWing 828. 模拟栈](https://www.acwing.com/problem/content/830/):这道题用地是系统自带的stack
    ```java
    import java.io.*;

    public class Main {

        static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        static final int N = 100010;
        static int[] stack = new int[N];      // 数据规模为 10w
        static int tt = 0;                  // 指向栈顶的指针

        static void push(int val) {
            stack[++tt] = val;
        }

        static void pop() {
            tt--;
        }

        static boolean empty() {
            return tt == 0;
        }

        static int query() {
            return stack[tt];
        }

        public static void main(String[] args) throws IOException {
            int m = Integer.parseInt(reader.readLine());
            while (m-- > 0) {
                String[] s = reader.readLine().split(" ");
                switch (s[0]) {
                    case "push":
                        push(Integer.parseInt(s[1]));
                        break;
                    case "pop":
                        pop();
                        break;
                    case "query":
                        System.out.println(query());
                        break;
                    case "empty":
                        if (empty()) System.out.println("YES");
                        else System.out.println("NO");
                        break;
                    default:
                        throw new IllegalStateException("Unexpected value: " + s[0]);
                }
            }
        }
    }
    ```

### 2.2 单调栈
> 常见模型：**找出每个数左边离它最近的比它大/小的数**。参考博客[单调栈和单调队列的理解](https://blog.csdn.net/shxifs/article/details/101058167)

+ [AcWing 830. 单调栈](https://www.acwing.com/problem/content/832/)
    ```java
    // 这里用单调递增栈，单调栈和单调队列的理解见博客：https://blog.csdn.net/shxifs/article/details/101058167
    import java.util.*;

    public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            Stack<Integer> st = new Stack<>();
            int n = sc.nextInt();
            for (int i = 0; i < n; i++) {
                int x = sc.nextInt();
                // 只要栈不为空，且栈顶元素不比x小，则弹出栈顶元素。每个元素入栈一次出栈一次，所以时间复杂度为O(1)
                while (!st.isEmpty() && x <= st.peek()) st.pop();
                int nearestMin = st.isEmpty() ? -1 : st.peek();
                System.out.print(nearestMin + " ");
                st.push(x); // 插入x仍然保持住单调递增栈的特性
            }
        }
    }
    ```

## 3.队列
### 3.1 普通队列
+ [AcWing 829. 模拟队列](https://www.acwing.com/problem/content/831/)
    ```java
    import java.io.*;

    public class Main {

        static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        static final int N = 100010;
        static int[] q = new int[N];      // 数据规模为 10w
        static int hh = 0, tt =-1;      // hh指向队头, tt指向队尾

        // 入队
        static void push(int val) {
            q[++tt] = val;
        }

        // 出队
        static void pop() {
            hh++;
        }

        // 判断队列是否为空
        static boolean empty() {
            return hh > tt;
        }

        // 查询队头元素
        static int query() {
            return q[hh];
        }

        // 查询队尾元素
        static int queryToTail() {
            return q[tt];
        }
        
        public static void main(String[] args) throws IOException {
            int m = Integer.parseInt(reader.readLine());

            while (m-- > 0) {
                String[] s = reader.readLine().split(" ");
                switch (s[0]) {
                    case "push":
                        push(Integer.parseInt(s[1]));
                        break;
                    case "pop":
                        pop();
                        break;
                    case "query":
                        System.out.println(query());
                        break;
                    default:     // s[0].equals("empty")
                        if (empty()) System.out.println("YES");
                        else System.out.println("NO");
                        break;
                }
            }
        }
    }
    ```

### 3.2 单调队列
> 常见模型：**找出滑动窗口中的最大值/最小值**。参考博客[单调栈和单调队列的理解](https://blog.csdn.net/shxifs/article/details/101058167)。时间复杂度是O(n)。

+ [AcWing 154. 滑动窗口](https://www.acwing.com/problem/content/156/)
    ```java
    // 单调队列，单调栈和单调队列的理解见博客：https://blog.csdn.net/shxifs/article/details/101058167
    import java.io.BufferedReader;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.util.*;
    public class Main {
        public static void main(String[] args) throws IOException {
            BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
            String[] nk = bf.readLine().split(" ");
            int n = Integer.parseInt(nk[0]), k = Integer.parseInt(nk[1]);
            int[] a = new int[n + 1];
            String[] as = bf.readLine().split(" ");
            for (int i = 1; i <= n; i++) a[i] = Integer.parseInt(as[i - 1]);
            StringBuilder sb = new StringBuilder();
            // 单调递增队列(队头到队尾递增)，队头就是最小值
            Deque<Integer> qAsc = new ArrayDeque<>();
            for (int i = 1; i <= n; i++) {
                // 队里不为空，且队尾元素不比当前元素小，则不断弹出队尾元素
                while (!qAsc.isEmpty() && a[qAsc.getLast()] >= a[i]) qAsc.pollLast();
                // 直到找到队尾元素比当前元素小，则把当前元素插入到队尾，满足从队头到队尾递增
                qAsc.addLast(i);
                // 保证队列检查了a数组中的k个元素，即维持滑动窗口的宽度为k
                while (!qAsc.isEmpty() && i - k >= qAsc.getFirst()) qAsc.pollFirst();
                // 队列头元素就是最小元素 .i >= k是为了初始时先让滑动窗口挤满k个元素，然后再求滑动窗口内的最小值才有意义
                if (i >= k) sb.append(a[qAsc.getFirst()]).append(" ");
            }
            sb.append("\n");
            // 单调递减队列(队头到队尾递减)，队头就是最大值
            Deque<Integer> qDsc = new ArrayDeque<>();
            for (int i = 1; i <= n; i++) {
                // 队里不为空，且队尾元素不比当前元素大，则不断弹出队尾元素
                while (!qDsc.isEmpty() && a[qDsc.getLast()] <= a[i]) qDsc.pollLast();
                // 直到找到队尾元素比当前元素大，则把当前元素插入到队尾，满足从队头到队尾递减
                qDsc.addLast(i);
                // 保证队列检查了a数组中的k个元素，即维持滑动窗口的宽度为k
                while (!qDsc.isEmpty() && i - k >= qDsc.getFirst()) qDsc.pollFirst();
                // 队列头元素就是最大元素 .i >= k是为了初始时先让滑动窗口挤满k个元素，然后再求滑动窗口内的最大值才有意义
                if (i >= k) sb.append(a[qDsc.getFirst()]).append(" ");
            }
            System.out.println(sb.toString());
        }
    }
    ```

## 4.KMP算法
> 主串长度为n，模式字符串长度m，则KMP算法的空间复杂度为O(m),时间复杂度为O(n)。参考博客
+ [漫画：什么是字符串匹配算法？](https://blog.csdn.net/bjweimengshu/article/details/103966767)
+ [漫画：如何优化 “字符串匹配算法”？](https://blog.csdn.net/bjweimengshu/article/details/104368394)
+ [漫画：什么是KMP算法？](https://blog.csdn.net/bjweimengshu/article/details/104528964):重要
+ [阮一峰：字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

### 4.1 代码步骤
+ 1. 对模式串预处理，生成next数组
+ 2. 进入主循环，遍历主串
  + 2.1. 比较主串和模式串的字符
  + 2.2. 如果发现坏字符，查询next数组，得到匹配前缀所对应的最长可匹配前缀子串，移动模式串到对应位置
  + 2.3.如果当前字符匹配，继续循环

### 4.2 模板代码C++

```cpp
#include <iostream>

const int M = 1e5 + 10, N = 1e6 + 10;

using namespace std;

int main(void) {
    int n, m;
    char s[N], p[M];
    int next[M];
    cin >> m >> p + 1 >> n >> s + 1;
    // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
    // 求模式串的next数组：
    for (int i = 2, j = 0; i <= m; i ++ ) {
        while (j && p[i] != p[j + 1]) j = next[j];
        if (p[i] == p[j + 1]) j ++ ;
        next[i] = j;
    }
    
    // 匹配
    for (int i = 1, j = 0; i <= n; i ++ ) {
        while (j && s[i] != p[j + 1]) j = next[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == m) {
            j = next[j];
            // 匹配成功后的逻辑，i - m就是匹配到的位置的坐标
            cout << (i - m) << endl;
        }
    }
    return 0;
}
```

### 4.3 模板代码Java
```java
public class KMP {
    // KMP算法主体逻辑。str是主串，pattern是模式串
    public static int kmp(String str, String pattern) {
        //预处理，生成next数组
        int[] next = getNexts(pattern);
        int j = 0;
        //主循环，遍历主串字符
        for (int i = 0; i < str.length(); i++) {
            while (j > 0 && str.charAt(i) != pattern.charAt(j)) {
                //遇到坏字符时，查询next数组并改变模式串的起点
                j = next[j];
            }
            if (str.charAt(i) == pattern.charAt(j)) {
                j++;
            }
            if (j == pattern.length()) {
                //匹配成功，返回下标
                return i - pattern.length() + 1;
            }
        }
        return -1;
    }

    // 生成Next数组
    private static int[] getNexts(String pattern) {
        int[] next = new int[pattern.length()];
        int j = 0;
        for (int i = 2; i < pattern.length(); i++) {
            while (j != 0 && pattern.charAt(j) != pattern.charAt(i - 1)) {
                //从next[i+1]的求解回溯到 next[j]
                j = next[j];
            }
            if (pattern.charAt(j) == pattern.charAt(i - 1)) {
                j++;
            }
            next[i] = j;
        }
        return next;
    }

    public static void main(String[] args) {
        String str = "ATGTGAGCTGGTGTGTGCFAA";
        String pattern = "GTGTGCF";
        int index = kmp(str, pattern);
        System.out.println("首次出现位置：" + index);
    }
}
```

### 4.4 C++自带的字符串匹配的实现
> 性能比上面4.2地差一些，左下面的题目会超时
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n, m, idx;
    string s, p;
    cin >> n >> p >> m >> s;
    idx = s.find(p);
    while(idx != std::string::npos) {
        cout << idx << ' ';
        idx = s.find(p, idx + 1);
    }
    return 0;
}
```

### 4.5 题目
> [831.KMP字符串](https://www.acwing.com/problem/content/833/) 参考题解：https://www.acwing.com/solution/content/11332/

```java
// 参考：https://www.acwing.com/solution/content/11332/
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // 模式串p长度
        char[] p = (" " + scanner.next()).toCharArray(); // 模式串p
        int m = scanner.nextInt(); // 总串s长度
        char[] s = (" " + scanner.next()).toCharArray(); // 总串s

        // 构造前缀数组
        int[] prefix = new int[n + 1];
        for (int i = 2, j = 0; i <= n; i++) {
            // i从2开始，因为prefix[1]肯定为0
            while (j != 0 && p[i] != p[j + 1]) j = prefix[j];
            if (p[i] == p[j + 1]) j++;
            prefix[i] = j;
        }

        StringBuilder sb = new StringBuilder();

        // kmp匹配
        for (int i = 1, j = 0; i <= m; i++) {
            while (j != 0 && s[i] != p[j + 1]) j = prefix[j]; // s[i] != p[j + 1]即不匹配，则往后移动
            if (s[i] == p[j + 1]) j++; // 匹配时将j++进行下一个字符得匹配
            if (j == n) { // 匹配了n字符了即代表完全匹配了
               sb.append(i - n).append(" ");
                j = prefix[j]; // 完全匹配后继续搜索
            }
        }
        System.out.println(sb.toString());
    }
}
```

## 5.Trie树
## 5.1 参考资料
> 参考之前自己整理的资料：[Part2Basic/第10章_Trie字典树.md](../../Part2Basic/第10章_Trie字典树.md)
## 5.2 模板代码
> 以[AcWing 835. Trie字符串统计](https://www.acwing.com/problem/content/837/)为例
```cpp
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点, 其中存放的是：子节点对应的idx。其中son数组的第一维是：父节点对应的idx，第第二维计数是：其直接子节点('a' - '0')的值为二维下标。
// cnt[]存储以每个节点结尾的单词数量. 以“abc”字符串为例，最后一个字符---‘c’对应的idx作为cnt数组的下标。数组的值是该idx对应的个数。
// 将该字符串分配的一个树结构中，以下标来记录每一个字符的位置。方便之后的插入和查找。

// 插入一个字符串
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx; // 更新到当前节点对应的单词出现的次数
        p = son[p][u]; // 不停沿着树的子节点往下按找
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0; // 往下没有子节点了，即不存在这个单词，直接返回0
        p = son[p][u]; // 不停沿着树的子节点往下按找
    }
    return cnt[p]; // 
}

int main(void) {
    int n;
    scanf("%d", &n);
    char op[2]; // 字符串最后要有结束符\0
    char str[N];
    while (n--) {
        scanf("%s%s", op, str);
        if (op[0] == 'I') insert(str);
        else printf("%d\n", query(str));
    }
}
```

> Java实现如下：

```java
// 参考：https://www.acwing.com/solution/content/11778/
import java.io.*;
import java.util.*;

class Main {
    static class Node {
        char val;
        int count;
        Map<Character, Node> children;

        Node() {
        }

        Node(char val) {
            this.val = val;
        }
    }

    static Node root;

    public static void insert(String s) {
        Node node = root;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (node.children == null) node.children = new HashMap<>();
            if (!node.children.containsKey(c)) node.children.put(c, new Node(c));
            node = node.children.get(c);
        }
        node.count++;
    }

    public static int search(String s) {
        Node node = root;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (node.children == null || !node.children.containsKey(c)) return 0;
            node = node.children.get(c);
        }
        return node.count;
    }

    static BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
    static BufferedWriter log = new BufferedWriter(new OutputStreamWriter(System.out));

    public static void main(String[] args) throws Exception {
        int n = Integer.parseInt(read.readLine());
        String[] s;
        root = new Node();
        for (int i = 0; i < n; i++) {
            s = read.readLine().split(" ");
            if ("I".equals(s[0])) {
                insert(s[1]);
            } else {
                log.write(search(s[1]) + "\n");
            }
        }
        log.flush();
    }
}
```

### 5.3 题目：[AcWing 143.最大异或对](https://www.acwing.com/problem/content/description/145/)
```java
import java.util.*;
import java.io.*;

class Main{
    static int N = 100000, M = 3000000, idx = 0;
    static int[][] son = new int[M][2];
    static int[] a = new int [N];

    //插入模板
    static void insert(int x){
        //p为父节点
        int p = 0;
        //31 位, i >= 0, 一共执行31次
        for(int i = 30; i>= 0; i--){
            //trie树 左移i位是否是1, 如果没此节点则创建.
            if(son[p][x >> i & 1] == 0)
                son[p][x >> i & 1] = ++ idx;
            //更新父节点为子节点
            p = son[p][x >> i & 1];
        }
    }
    static int query(int x){
        int p = 0, res = 0;
        for (int i = 30; i>=0; i--){
            //左移i为是否为1;
            int s = x >> i & 1;
            //异或数
            int sp = s == 0 ? 1 : 0;
            //如果有异或数
            if(son[p][sp] != 0){
                //则这一位上的异或数为1;
                //末尾加1, 往左移i位.
                res += 1 << i;
                //更新为异或数
                p = son[p][sp];
            }else{
                //没有异或数则更新原数字的子节点.
                p = son[p][s];
            }
        }
        return res;
    }

    public static void main(String args[])throws IOException{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(in.readLine());
        a = Arrays.asList(in.readLine().split(" ")).stream().mapToInt(Integer::parseInt).toArray();

        for (int i =0; i < n; i++){
            insert(a[i]);
        }

        int res = 0;
        for (int i =0; i< n; i++){
            res = Math.max(res, query(a[i]));
        }
        System.out.print(res);
    }
}

// 链接：https://www.acwing.com/solution/content/8675/
```

## 6.并查集
### (1)朴素并查集：
```cpp
int p[N]; //存储每个点的祖宗节点

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```

### (2)维护size的并查集：
```cpp
int p[N], size[N];
//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

// 返回x的祖宗节点
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    size[i] = 1;
}

// 合并a和b所在的两个集合：
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

### (3)维护到祖宗节点距离的并查集：
```cpp
int p[N], d[N];
//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

// 返回x的祖宗节点
int find(int x) {
    if (p[x] != x) {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}

// 初始化，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) {
    p[i] = i;
    d[i] = 0;
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

### (4)完善的并查集的Java实现
```java
class UnionFind {

    /**
     * 记录每个节点在联通分量中的父节点
     */
    private int[] parent;

    /**
     * rank[i]表示节点i所在的联通分量树的层数/高度/深度
     */
    private int[] rank;

    public UnionFind(int size) {
        this.parent = new int[size];
        this.rank = new int[size];
        for (int i = 0; i < parent.length; i++) {
            // 初始化时每个顶点的父节点都认为是自己
            parent[i] = i;
            // 初始时所有元素都是互不相连地，所以每个元素都是一个并查集，每个并查集只有一个元素,也就是一层
            rank[i] = 1;
        }
    }

    public boolean isConnected(int p, int q) {
        return find(p) == find(q);
    }

    public void unionElements(int p, int q) {
        int pRoot = find(p);
        int qRoot = find(q);
        if (pRoot == qRoot) {
            // p和q在一个联通分量内，不需要union了，直接退出
            return;
        }
        // 不在一个并查集内的话，只需要把两个根节点连接起来即可
        // 第5节：根据层数优化。下面按照两个并并查集的层数(rank[i])的大小决定谁连接谁(层数少地连接层数多地)
        if (rank[pRoot] < rank[qRoot]) { // p所在的并查集层数小于q所在的并查集层数，p指向q
            // p所在的并查集连接q所在的并查集，rank[root]取两者中层数较大地，并不需要维护rank
            parent[pRoot] = qRoot;
        } else if (rank[pRoot] > rank[qRoot]) { // p所在的并查集层数大于q所在的并查集层数,q指向p
            // p所在的并查集连接q所在的并查集，rank[root]取两者中层数较大地，并不需要维护rank
            // q所在的并查集连接p所在的并查集
            parent[qRoot] = pRoot;
        } else { // p所在的并查集层数等于q所在的并查集层数,谁指向谁都行，这里选p指向q
            //当 rank[pRoot] = rank[qRoot];
            parent[pRoot] = qRoot;
            // 两个层级相等的并查集树根节点相连，层数一定增长1，所以把新的并查集层数+1
            rank[qRoot] += 1;
        }
    }

    public int getSize() {
        return parent.length;
    }

    /**
     * 获取元素i所属的联通分量的根节点，因为是树，所以查找的时间复杂度是O(logn)
     *
     * @param i 元素，即parent数组的下标，用来唯一标识一个元素，即parent数组的下标既是索引又是元素
     * @return i所属的联通分量的根节点
     */
    private int find(int i) {
        if (i < 0 || i >= parent.length) {
            throw new IllegalArgumentException("传入的索引超出了数组范围！");
        }
        // 当i的父节点是自己时说明达到了根节点
        while (parent[i] != i) {
            // 第6节：路径压缩
            parent[i] = parent[parent[i]];
            i = parent[i];
        }
        return i;
    }
}
```

## 7.堆

## 8.哈希

## 9.C++ STL简介
```txt
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```