# 《[程序猿的内功修炼，学好算法与数据结构](https://coding.imooc.com/class/71.html)》

> 主要是介绍常见的基础算法，如排序、树的访问、图算法等。

[课程链接](https://coding.imooc.com/learn/list/71.html)

+ 第1章 当我们谈论算法的时候，我们在谈论什么？
  + 1-1 我们究竟为什么要学习算法  (15:33)
  + 1-2 课程介绍  (12:22)

+ 第2章 排序基础
  + 2-1 选择排序法 - Selection Sort  (08:45)
  + 2-2 使用模板（泛型）编写算法  (11:22)
  + 2-3 随机生成算法测试用例  (09:46)
  + 2-4 测试算法的性能  (08:41)
  + 2-5 插入排序法 - Insertion Sort  (11:01)
  + 2-6 插入排序法的改进  (11:15)
  + 2-7 更多关于O(n^2)排序算法的思考  (05:39)

+ 第3章 高级排序算法
  + 3-1 归并排序法 - Merge Sort  (12:36)
  + 3-2 归并排序法的实现  (12:38)
  + 3-3 归并排序法的优化  (08:08)
  + 3-4 自底向上的归并排序算法  (08:30)
  + 3-5 快速排序法 - Quick Sort  (14:31)
  + 3-6 随机化快速排序法  (09:50)
  + 3-7 双路快速排序法  (12:51)
  + 3-8 三路快速排序法  (15:34)
  + 3-9 归并排序和快速排序的衍生问题  (13:10)

+ 第4章 堆和堆排序
  + 4-1 为什么使用堆？  (10:30)
  + 4-2 堆的基本存储  (12:10)
  + 4-3 Shift Up  (11:12)
  + 4-4 Shift Down  (11:32)
  + 4-5 基础堆排序和Heapify  (16:04)
  + 4-6 优化的堆排序（Heap Sort）  (11:49)
  + 4-7 排序算法总结  (12:49)
  + 4-8 索引堆(Index Heap)  (16:20)
  + 4-9 索引堆的优化  (12:51)
  + 4-10 和堆相关的其他问题  (11:30)

+ 第5章 二分搜索树
  + 5-1 二分查找法（Binary Search）  (16:14)
  + 5-2 二分搜索树基础 （Binary Search Tree）  (11:50)
  + 5-3 二分搜索树的节点插入  (08:55)
  + 5-4 二分搜索树的查找  (13:58)
  + 5-5 二分搜索树的遍历（深度优先遍历）  (15:24)
  + 5-6 层序遍历（广度优先遍历）  (08:09)
  + 5-7 删除最大值，最小值  (13:20)
  + 5-8 二分搜索树节点的删除（Hubbard Deletion）  (16:41)
  + 5-9 二分搜索树的顺序性  (10:35)
  + 5-10 二分搜索树的局限性  (13:36)
  + 5-11 树形问题和更多树  (07:57)

+ 第6章 并查集
  + 6-1 并查集基础（Union Find）  (09:05)
  + 6-2 Quick Find  (11:30)
  + 6-3 Quick Union  (13:24)
  + 6-4 基于size的优化  (07:33)
  + 6-5 基于rank的优化  (06:35)
  + 6-6 路径压缩 (Path Compression)  (14:09)

+ 第7章 图的基础
  + 7-1 图论基础  (12:54)
  + 7-2 图的表示  (19:27)
  + 7-3 相邻结点迭代器  (15:07)
  + 7-4 图的算法框架  (08:41)
  + 7-5 深度优先遍历和联通分量  (17:44)
  + 7-6 寻路  (13:48)
  + 7-7 广度优先遍历和最短路径  (15:01)
  + 7-8 迷宫生成，PS抠图——更多无权图的应用  (14:28)

+ 第8章 最小生成树
  + 8-1 有权图  (18:10)
  + 8-2 最小生成树问题和切分定理  (08:35)
  + 8-3 Prim算法的第一个实现 （Lazy Prim）  (18:55)
  + 8-4 Prim算法的优化  (12:02)
  + 8-5 优化后的Prim算法的实现  (11:58)
  + 8-6 Krusk算法  (14:36)
  + 8-7 最小生成树算法的思考  (05:46)

+ 第9章 最短路径
  + 9-1 最短路径问题和松弛操作（Relaxation）  (08:24)
  + 9-2 Dijkstra算法的思想  (12:20)
  + 9-3 实现Dijkstra算法  (12:18)
  + 9-4 负权边和Bellman-Ford算法  (11:05)
  + 9-5 实现Bellman-Ford算法  (10:10)
  + 9-6 更多和最短路径相关的思考  (11:15)
