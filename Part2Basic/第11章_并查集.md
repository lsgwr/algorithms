# 第11章 并查集
> 两个点之间在树或图中是否连通的问题。

在[《玩转数据结构C++版 第6章》](../Part1Basic/第6章_并查集.md)和[《图论基础 Java版》第4章](../Part2BasicGraph/第04章_图的深度优先遍历的应用.md#42-求每个连通分量里各自具体有哪些节点)都有讲到相关问题

## 11.1 什么是并查集？
### 连接问题
+ 网络中节点间的连接状态
+ 数学中的集合类实现
### 连接问题与路径问题：
+ 解决路径问题便一定可以解决连接问题，但由于路径问题考虑了更多与连接问题无关的操作，使得用处理路径问题的方式处理连接问题性能较差。
+ 类似的，实现最大/最小堆的数据结构完全可以用有序数组的结构替代，但由于顺序表的每次操作都需要遍历整个数组，因此不仅可以找到最大最小的元素，也可以找到其它的元素，但也因为这样，使用顺序表实现堆的操作性能较差
### 并查集要支持的接口
+ `union(p, q)`:把p和q连接起来，将两个元素连接起来，等效于p、q所在的网络两个连接到了一起，两个网络内的顶点就都连接到一起了，我自己的实现叫`unionElements(p, q)`
+ `isConnected(p, q)`：判断p和q是否是连接的
### [并查集基础的接口](src/main/java/Chapter11UnionFind/UF.java)
```java
/***********************************************************
 * @Description : 并查集的基础接口
 * @author      : 梁山广(Laing Shan Guang)
 * @date        : 2020/1/2 18:58
 * @email       : liangshanguang2@gmail.com
 ***********************************************************/
package Chapter11UnionFind;

public interface UF {
    /**
     * 判断p和q是否是联通
     *
     * @param p 顶点p
     * @param q 顶点q
     * @return p和q是联通返回true，否则返回false
     */
    boolean isConnected(int p, int q);

    /**
     * 把定点p和q联通起来，等效于把p和q所在的联通分量连接到一起，称为一个联通分量
     *
     * @param p 顶点p
     * @param q 顶点q
     */
    void unionElements(int p, int q);

    /**
     * 获取并查集内的元素个数
     * @return  并查集内的元素个数
     */
    int getSize();
}

```

## 11.2 并查集第1版：Quick Find
> 我们把所有的点存入一个`int[] id`数组，联通的点在id内的值相等，比如`id[p]=id[q]`表明p和q在一个联通分量内。id[p]和id[q]可以看做是联通分量的唯一标记即id

比如下面图,
+ 0、1、2、3、4在下面id数组中的值均为0，所以它们都在一个联通分量内
+ 5、6、7、8、9在下面id数组中的值均为1，所以它们都在一个联通分量内
![id数组来表示不同的并查集例子1](https://img1.sycdn.imooc.com/szimg/5e0dab940001d43119201080.jpg)

再比如下面的图：
+ 0、2、4、6、8在下面id数组中的值均为0，所以它们都在一个联通分量内
+ 1、3、5、7、9在下面id数组中的值均为1，所以它们都在一个联通分量内
![id数组来表示不同的并查集例子2](https://img.mukewang.com/szimg/5e0dac310001a5a319201080.jpg)

所以实现`isConnected(p, q)`实际就是判断id[p]和id[q]是否相等，由于后面id数组的形式还会优化，所以我们把获取p和q所在联通分量的id的函数封装成find(p)和find(q)，我们直接判断find(p)和find(q)是否相等即可

因为直接在数组中取值，不需要遍历，所以我们的`find()`实现是`O(1)`级别的，不能更高了，所以本节实现的是Quick Find

```java
public class UnionFind implements UF {

    /**
     * 存储每个节点所在的联通分量id的数组
     */
    private int[] id;

    public UnionFind(int size) {
        this.id = new int[size];
        for (int i = 0; i < id.length; i++) {
            // 初始化时每个顶点的联通分量id都不同
            id[i] = i;
        }
    }

    ...

    /**
     * 获取元素e所属的联通分量编号,因为直接在数组中取值，所以是O(1)级别的
     *
     * @param i 元素，即id数组的下标，用来唯一标识一个元素，即id数组的下标既是索引又是元素
     * @return e所属的联通分量编号
     */
    private int find(int i) {
        if (i < 0 || i >= id.length) {
            throw new IllegalArgumentException("传入的索引超出了数组范围！");
        }
        return id[i];
    }
}
```

但是union操作时间复杂度会很高，下面分析下：
如下图，为了把属于两个联通分量的1和4连接起来，即实现`union(1, 4)`，我们把4在id数组中的值改成和1的一样，即id[4]从0改成1，
![QuickFind下的union操作](https://img.mukewang.com/szimg/5e0db7d70001026f19201080.jpg)
为了保持0、2、6、8和4仍然在一个联通分量内需要把id[0]、id[2]、id[6]、id[8]也从0改成1，为了完成这个操作需要对id数组执行一轮循环，所以此时的union操作是O(n)级别的
![QuickFind下的union操作2](https://img1.sycdn.imooc.com/szimg/5e0db83e00012a4619201080.jpg)

代码实现如下：

```java
@Override
public void unionElements(int p, int q) {
    int pID = find(p);
    int qID = find(q);
    if (pID == qID) {
        return;
    }
    // pID的元素改成qID或者qID改成pID都可以，这里我们把pID的元素改成qID
    for (int i = 0; i < id.length; i++) {
        if (id[i] == pID) {
            id[i] = qID;
        }
    }
}
```

综上，Quick Find一般就意味着Slow Union，基于id数组的UnionFind中的find()和union的操作时间复杂度如下：


| 方法                | 时间复杂度 |
| ------------------- | ---------- |
| find(i)             | O(1)       |
| unionElements(p, q) | O(n)       |

[本节的完整代码实现](src/main/java/Chapter11UnionFind/Section2QuickFind/UnionFind.java)